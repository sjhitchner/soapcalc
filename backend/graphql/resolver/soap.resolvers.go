package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.

import (
	"context"
	"fmt"

	generated "github.com/sjhitchner/soapcalc/backend/generated/graphql"
	gmodels "github.com/sjhitchner/soapcalc/backend/generated/graphql/models"
)

func (r *mutationResolver) CreateAdditive(ctx context.Context, input gmodels.AdditiveCreateInput) (*gmodels.AdditivePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateAdditive(ctx context.Context, id string, input gmodels.AdditiveUpdateInput) (*gmodels.AdditivePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteAdditive(ctx context.Context, id string) (*gmodels.AdditiveDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateAdditiveInventory(ctx context.Context, input gmodels.AdditiveInventoryCreateInput) (*gmodels.AdditiveInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateAdditiveInventory(ctx context.Context, id string, input gmodels.AdditiveInventoryUpdateInput) (*gmodels.AdditiveInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteAdditiveInventory(ctx context.Context, id string) (*gmodels.AdditiveInventoryDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateFragrance(ctx context.Context, input gmodels.FragranceCreateInput) (*gmodels.FragrancePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateFragrance(ctx context.Context, id string, input gmodels.FragranceUpdateInput) (*gmodels.FragrancePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteFragrance(ctx context.Context, id string) (*gmodels.FragranceDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateFragranceInventory(ctx context.Context, input gmodels.FragranceInventoryCreateInput) (*gmodels.FragranceInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateFragranceInventory(ctx context.Context, id string, input gmodels.FragranceInventoryUpdateInput) (*gmodels.FragranceInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteFragranceInventory(ctx context.Context, id string) (*gmodels.FragranceInventoryDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateLipid(ctx context.Context, input gmodels.LipidCreateInput) (*gmodels.LipidPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateLipid(ctx context.Context, id string, input gmodels.LipidUpdateInput) (*gmodels.LipidPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteLipid(ctx context.Context, id string) (*gmodels.LipidDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateLipidInventory(ctx context.Context, input gmodels.LipidInventoryCreateInput) (*gmodels.LipidInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateLipidInventory(ctx context.Context, id string, input gmodels.LipidInventoryUpdateInput) (*gmodels.LipidInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteLipidInventory(ctx context.Context, id string) (*gmodels.LipidInventoryDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateLye(ctx context.Context, input gmodels.LyeCreateInput) (*gmodels.LyePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateLye(ctx context.Context, id string, input gmodels.LyeUpdateInput) (*gmodels.LyePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteLye(ctx context.Context, id string) (*gmodels.LyeDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateLyeInventory(ctx context.Context, input gmodels.LyeInventoryCreateInput) (*gmodels.LyeInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateLyeInventory(ctx context.Context, id string, input gmodels.LyeInventoryUpdateInput) (*gmodels.LyeInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteLyeInventory(ctx context.Context, id string) (*gmodels.LyeInventoryDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipe(ctx context.Context, input gmodels.RecipeCreateInput) (*gmodels.RecipePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipe(ctx context.Context, id string, input gmodels.RecipeUpdateInput) (*gmodels.RecipePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipe(ctx context.Context, id string) (*gmodels.RecipeDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeAdditive(ctx context.Context, input gmodels.RecipeAdditiveCreateInput) (*gmodels.RecipeAdditivePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeAdditive(ctx context.Context, id string, input gmodels.RecipeAdditiveUpdateInput) (*gmodels.RecipeAdditivePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeAdditive(ctx context.Context, id string) (*gmodels.RecipeAdditiveDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeBatch(ctx context.Context, input gmodels.RecipeBatchCreateInput) (*gmodels.RecipeBatchPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeBatch(ctx context.Context, id string, input gmodels.RecipeBatchUpdateInput) (*gmodels.RecipeBatchPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeBatch(ctx context.Context, id string) (*gmodels.RecipeBatchDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeBatchAdditive(ctx context.Context, input gmodels.RecipeBatchAdditiveCreateInput) (*gmodels.RecipeBatchAdditivePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeBatchAdditive(ctx context.Context, id string, input gmodels.RecipeBatchAdditiveUpdateInput) (*gmodels.RecipeBatchAdditivePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeBatchAdditive(ctx context.Context, id string) (*gmodels.RecipeBatchAdditiveDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeBatchFragrance(ctx context.Context, input gmodels.RecipeBatchFragranceCreateInput) (*gmodels.RecipeBatchFragrancePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeBatchFragrance(ctx context.Context, id string, input gmodels.RecipeBatchFragranceUpdateInput) (*gmodels.RecipeBatchFragrancePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeBatchFragrance(ctx context.Context, id string) (*gmodels.RecipeBatchFragranceDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeBatchLipid(ctx context.Context, input gmodels.RecipeBatchLipidCreateInput) (*gmodels.RecipeBatchLipidPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeBatchLipid(ctx context.Context, id string, input gmodels.RecipeBatchLipidUpdateInput) (*gmodels.RecipeBatchLipidPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeBatchLipid(ctx context.Context, id string) (*gmodels.RecipeBatchLipidDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeBatchLye(ctx context.Context, input gmodels.RecipeBatchLyeCreateInput) (*gmodels.RecipeBatchLyePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeBatchLye(ctx context.Context, id string, input gmodels.RecipeBatchLyeUpdateInput) (*gmodels.RecipeBatchLyePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeBatchLye(ctx context.Context, id string) (*gmodels.RecipeBatchLyeDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeFragrance(ctx context.Context, input gmodels.RecipeFragranceCreateInput) (*gmodels.RecipeFragrancePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeFragrance(ctx context.Context, id string, input gmodels.RecipeFragranceUpdateInput) (*gmodels.RecipeFragrancePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeFragrance(ctx context.Context, id string) (*gmodels.RecipeFragranceDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeLipid(ctx context.Context, input gmodels.RecipeLipidCreateInput) (*gmodels.RecipeLipidPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeLipid(ctx context.Context, id string, input gmodels.RecipeLipidUpdateInput) (*gmodels.RecipeLipidPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeLipid(ctx context.Context, id string) (*gmodels.RecipeLipidDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateSupplier(ctx context.Context, input gmodels.SupplierCreateInput) (*gmodels.SupplierPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateSupplier(ctx context.Context, id string, input gmodels.SupplierUpdateInput) (*gmodels.SupplierPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteSupplier(ctx context.Context, id string) (*gmodels.SupplierDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Additive(ctx context.Context, id string) (*gmodels.Additive, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Additives(ctx context.Context, filter *gmodels.AdditiveFilter) ([]*gmodels.Additive, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) AdditiveInventory(ctx context.Context, id string) (*gmodels.AdditiveInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) AdditiveInventories(ctx context.Context, filter *gmodels.AdditiveInventoryFilter) ([]*gmodels.AdditiveInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Fragrance(ctx context.Context, id string) (*gmodels.Fragrance, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Fragrances(ctx context.Context, filter *gmodels.FragranceFilter) ([]*gmodels.Fragrance, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) FragranceInventory(ctx context.Context, id string) (*gmodels.FragranceInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) FragranceInventories(ctx context.Context, filter *gmodels.FragranceInventoryFilter) ([]*gmodels.FragranceInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Lipid(ctx context.Context, id string) (*gmodels.Lipid, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Lipids(ctx context.Context, filter *gmodels.LipidFilter) ([]*gmodels.Lipid, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) LipidInventory(ctx context.Context, id string) (*gmodels.LipidInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) LipidInventories(ctx context.Context, filter *gmodels.LipidInventoryFilter) ([]*gmodels.LipidInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Lye(ctx context.Context, id string) (*gmodels.Lye, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Lyes(ctx context.Context, filter *gmodels.LyeFilter) ([]*gmodels.Lye, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) LyeInventory(ctx context.Context, id string) (*gmodels.LyeInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) LyeInventories(ctx context.Context, filter *gmodels.LyeInventoryFilter) ([]*gmodels.LyeInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Recipe(ctx context.Context, id string) (*gmodels.Recipe, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Recipes(ctx context.Context, filter *gmodels.RecipeFilter) ([]*gmodels.Recipe, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeAdditive(ctx context.Context, id string) (*gmodels.RecipeAdditive, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeAdditives(ctx context.Context, filter *gmodels.RecipeAdditiveFilter) ([]*gmodels.RecipeAdditive, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatch(ctx context.Context, id string) (*gmodels.RecipeBatch, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatches(ctx context.Context, filter *gmodels.RecipeBatchFilter) ([]*gmodels.RecipeBatch, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchAdditive(ctx context.Context, id string) (*gmodels.RecipeBatchAdditive, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchAdditives(ctx context.Context, filter *gmodels.RecipeBatchAdditiveFilter) ([]*gmodels.RecipeBatchAdditive, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchFragrance(ctx context.Context, id string) (*gmodels.RecipeBatchFragrance, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchFragrances(ctx context.Context, filter *gmodels.RecipeBatchFragranceFilter) ([]*gmodels.RecipeBatchFragrance, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchLipid(ctx context.Context, id string) (*gmodels.RecipeBatchLipid, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchLipids(ctx context.Context, filter *gmodels.RecipeBatchLipidFilter) ([]*gmodels.RecipeBatchLipid, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchLye(ctx context.Context, id string) (*gmodels.RecipeBatchLye, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchLyes(ctx context.Context, filter *gmodels.RecipeBatchLyeFilter) ([]*gmodels.RecipeBatchLye, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeFragrance(ctx context.Context, id string) (*gmodels.RecipeFragrance, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeFragrances(ctx context.Context, filter *gmodels.RecipeFragranceFilter) ([]*gmodels.RecipeFragrance, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeLipid(ctx context.Context, id string) (*gmodels.RecipeLipid, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeLipids(ctx context.Context, filter *gmodels.RecipeLipidFilter) ([]*gmodels.RecipeLipid, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Supplier(ctx context.Context, id string) (*gmodels.Supplier, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Suppliers(ctx context.Context, filter *gmodels.SupplierFilter) ([]*gmodels.Supplier, error) {
	panic(fmt.Errorf("not implemented"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
