// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package helpers

import (
	"github.com/sjhitchner/soapcalc/backend/generated/db/models"
	gmodels "github.com/sjhitchner/soapcalc/backend/generated/graphql/models"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/web-ridge/utils-go/boilergql"
)

func AdditiveCreateInputsToBoiler(am []*gmodels.AdditiveCreateInput) []*models.Additive {
	ar := make([]*models.Additive, len(am))
	for i, m := range am {
		ar[i] = AdditiveCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func AdditiveCreateInputToBoiler(
	m *gmodels.AdditiveCreateInput,
) *models.Additive {
	if m == nil {
		return nil
	}
	r := &models.Additive{
		Name:      m.Name,
		Note:      m.Note,
		CreatedAt: boilergql.IntToTimeDotTime(m.CreatedAt),
		UpdatedAt: boilergql.IntToTimeDotTime(m.UpdatedAt),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
	}
	return r
}

func AdditiveCreateInputToModelM(
	input map[string]interface{},
	m gmodels.AdditiveCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "name":
			modelM[models.AdditiveColumns.Name] = m.Name
		case "note":
			modelM[models.AdditiveColumns.Note] = m.Note
		case "createdAt":
			modelM[models.AdditiveColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.AdditiveColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		case "deletedAt":
			modelM[models.AdditiveColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		}
	}
	return modelM
}

func AdditiveCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "name":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveColumns.Name)
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveColumns.Note)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveColumns.UpdatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveColumns.DeletedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func AdditiveInventoryCreateInputsToBoiler(am []*gmodels.AdditiveInventoryCreateInput) []*models.AdditiveInventory {
	ar := make([]*models.AdditiveInventory, len(am))
	for i, m := range am {
		ar[i] = AdditiveInventoryCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func AdditiveInventoryCreateInputToBoiler(
	m *gmodels.AdditiveInventoryCreateInput,
) *models.AdditiveInventory {
	if m == nil {
		return nil
	}
	r := &models.AdditiveInventory{
		PurchaseDate: boilergql.IntToTimeDotTime(m.PurchaseDate),
		ExpiryDate:   boilergql.IntToTimeDotTime(m.ExpiryDate),
		Cost:         m.Cost,
		Weight:       m.Weight,
		AdditiveID:   int(boilergql.IDToBoiler(m.AdditiveID)),
		SupplierID:   int(boilergql.IDToBoiler(m.SupplierID)),
		UpdatedAt:    boilergql.IntToTimeDotTime(m.UpdatedAt),
		DeletedAt:    boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt:    boilergql.IntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func AdditiveInventoryCreateInputToModelM(
	input map[string]interface{},
	m gmodels.AdditiveInventoryCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "purchaseDate":
			modelM[models.AdditiveInventoryColumns.PurchaseDate] = boilergql.IntToTimeDotTime(m.PurchaseDate)
		case "expiryDate":
			modelM[models.AdditiveInventoryColumns.ExpiryDate] = boilergql.IntToTimeDotTime(m.ExpiryDate)
		case "cost":
			modelM[models.AdditiveInventoryColumns.Cost] = m.Cost
		case "weight":
			modelM[models.AdditiveInventoryColumns.Weight] = m.Weight
		case "additiveId":
			modelM[models.AdditiveInventoryColumns.AdditiveID] = int(boilergql.IDToBoiler(m.AdditiveID))
		case "supplierId":
			modelM[models.AdditiveInventoryColumns.SupplierID] = int(boilergql.IDToBoiler(m.SupplierID))
		case "updatedAt":
			modelM[models.AdditiveInventoryColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		case "deletedAt":
			modelM[models.AdditiveInventoryColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.AdditiveInventoryColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func AdditiveInventoryCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "purchaseDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.PurchaseDate)
		case "expiryDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.ExpiryDate)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.Cost)
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.Weight)
		case "additiveId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.AdditiveID)
		case "supplierId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.SupplierID)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.UpdatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func AdditiveInventoryUpdateInputsToBoiler(am []*gmodels.AdditiveInventoryUpdateInput) []*models.AdditiveInventory {
	ar := make([]*models.AdditiveInventory, len(am))
	for i, m := range am {
		ar[i] = AdditiveInventoryUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func AdditiveInventoryUpdateInputToBoiler(
	m *gmodels.AdditiveInventoryUpdateInput,
) *models.AdditiveInventory {
	if m == nil {
		return nil
	}
	r := &models.AdditiveInventory{
		PurchaseDate: boilergql.PointerIntToTimeDotTime(m.PurchaseDate),
		ExpiryDate:   boilergql.PointerIntToTimeDotTime(m.ExpiryDate),
		Cost:         boilergql.PointerFloat64ToFloat64(m.Cost),
		Weight:       boilergql.PointerFloat64ToFloat64(m.Weight),
		AdditiveID:   int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.AdditiveID))),
		SupplierID:   int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.SupplierID))),
		UpdatedAt:    boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
		DeletedAt:    boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt:    boilergql.PointerIntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func AdditiveInventoryUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.AdditiveInventoryUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "purchaseDate":
			modelM[models.AdditiveInventoryColumns.PurchaseDate] = boilergql.PointerIntToTimeDotTime(m.PurchaseDate)
		case "expiryDate":
			modelM[models.AdditiveInventoryColumns.ExpiryDate] = boilergql.PointerIntToTimeDotTime(m.ExpiryDate)
		case "cost":
			modelM[models.AdditiveInventoryColumns.Cost] = boilergql.PointerFloat64ToFloat64(m.Cost)
		case "weight":
			modelM[models.AdditiveInventoryColumns.Weight] = boilergql.PointerFloat64ToFloat64(m.Weight)
		case "additiveId":
			modelM[models.AdditiveInventoryColumns.AdditiveID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.AdditiveID)))
		case "supplierId":
			modelM[models.AdditiveInventoryColumns.SupplierID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.SupplierID)))
		case "updatedAt":
			modelM[models.AdditiveInventoryColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		case "deletedAt":
			modelM[models.AdditiveInventoryColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.AdditiveInventoryColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func AdditiveInventoryUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "purchaseDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.PurchaseDate)
		case "expiryDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.ExpiryDate)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.Cost)
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.Weight)
		case "additiveId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.AdditiveID)
		case "supplierId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.SupplierID)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.UpdatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveInventoryColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func AdditiveUpdateInputsToBoiler(am []*gmodels.AdditiveUpdateInput) []*models.Additive {
	ar := make([]*models.Additive, len(am))
	for i, m := range am {
		ar[i] = AdditiveUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func AdditiveUpdateInputToBoiler(
	m *gmodels.AdditiveUpdateInput,
) *models.Additive {
	if m == nil {
		return nil
	}
	r := &models.Additive{
		Name:      boilergql.PointerStringToString(m.Name),
		Note:      boilergql.PointerStringToString(m.Note),
		CreatedAt: boilergql.PointerIntToTimeDotTime(m.CreatedAt),
		UpdatedAt: boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
	}
	return r
}

func AdditiveUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.AdditiveUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "name":
			modelM[models.AdditiveColumns.Name] = boilergql.PointerStringToString(m.Name)
		case "note":
			modelM[models.AdditiveColumns.Note] = boilergql.PointerStringToString(m.Note)
		case "createdAt":
			modelM[models.AdditiveColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.AdditiveColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		case "deletedAt":
			modelM[models.AdditiveColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		}
	}
	return modelM
}

func AdditiveUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "name":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveColumns.Name)
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveColumns.Note)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveColumns.UpdatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.AdditiveColumns.DeletedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func FragranceCreateInputsToBoiler(am []*gmodels.FragranceCreateInput) []*models.Fragrance {
	ar := make([]*models.Fragrance, len(am))
	for i, m := range am {
		ar[i] = FragranceCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func FragranceCreateInputToBoiler(
	m *gmodels.FragranceCreateInput,
) *models.Fragrance {
	if m == nil {
		return nil
	}
	r := &models.Fragrance{
		Name:      m.Name,
		Note:      m.Note,
		CreatedAt: boilergql.IntToTimeDotTime(m.CreatedAt),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
		UpdatedAt: boilergql.IntToTimeDotTime(m.UpdatedAt),
	}
	return r
}

func FragranceCreateInputToModelM(
	input map[string]interface{},
	m gmodels.FragranceCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "name":
			modelM[models.FragranceColumns.Name] = m.Name
		case "note":
			modelM[models.FragranceColumns.Note] = m.Note
		case "createdAt":
			modelM[models.FragranceColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		case "deletedAt":
			modelM[models.FragranceColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "updatedAt":
			modelM[models.FragranceColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		}
	}
	return modelM
}

func FragranceCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "name":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceColumns.Name)
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceColumns.Note)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceColumns.CreatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceColumns.DeletedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceColumns.UpdatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func FragranceInventoryCreateInputsToBoiler(am []*gmodels.FragranceInventoryCreateInput) []*models.FragranceInventory {
	ar := make([]*models.FragranceInventory, len(am))
	for i, m := range am {
		ar[i] = FragranceInventoryCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func FragranceInventoryCreateInputToBoiler(
	m *gmodels.FragranceInventoryCreateInput,
) *models.FragranceInventory {
	if m == nil {
		return nil
	}
	r := &models.FragranceInventory{
		PurchaseDate: boilergql.IntToTimeDotTime(m.PurchaseDate),
		ExpiryDate:   boilergql.IntToTimeDotTime(m.ExpiryDate),
		Cost:         m.Cost,
		Weight:       m.Weight,
		FragranceID:  int(boilergql.IDToBoiler(m.FragranceID)),
		SupplierID:   int(boilergql.IDToBoiler(m.SupplierID)),
		DeletedAt:    boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt:    boilergql.IntToTimeDotTime(m.CreatedAt),
		UpdatedAt:    boilergql.IntToTimeDotTime(m.UpdatedAt),
	}
	return r
}

func FragranceInventoryCreateInputToModelM(
	input map[string]interface{},
	m gmodels.FragranceInventoryCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "purchaseDate":
			modelM[models.FragranceInventoryColumns.PurchaseDate] = boilergql.IntToTimeDotTime(m.PurchaseDate)
		case "expiryDate":
			modelM[models.FragranceInventoryColumns.ExpiryDate] = boilergql.IntToTimeDotTime(m.ExpiryDate)
		case "cost":
			modelM[models.FragranceInventoryColumns.Cost] = m.Cost
		case "weight":
			modelM[models.FragranceInventoryColumns.Weight] = m.Weight
		case "fragranceId":
			modelM[models.FragranceInventoryColumns.FragranceID] = int(boilergql.IDToBoiler(m.FragranceID))
		case "supplierId":
			modelM[models.FragranceInventoryColumns.SupplierID] = int(boilergql.IDToBoiler(m.SupplierID))
		case "deletedAt":
			modelM[models.FragranceInventoryColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.FragranceInventoryColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.FragranceInventoryColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		}
	}
	return modelM
}

func FragranceInventoryCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "purchaseDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.PurchaseDate)
		case "expiryDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.ExpiryDate)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.Cost)
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.Weight)
		case "fragranceId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.FragranceID)
		case "supplierId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.SupplierID)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.UpdatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func FragranceInventoryUpdateInputsToBoiler(am []*gmodels.FragranceInventoryUpdateInput) []*models.FragranceInventory {
	ar := make([]*models.FragranceInventory, len(am))
	for i, m := range am {
		ar[i] = FragranceInventoryUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func FragranceInventoryUpdateInputToBoiler(
	m *gmodels.FragranceInventoryUpdateInput,
) *models.FragranceInventory {
	if m == nil {
		return nil
	}
	r := &models.FragranceInventory{
		PurchaseDate: boilergql.PointerIntToTimeDotTime(m.PurchaseDate),
		ExpiryDate:   boilergql.PointerIntToTimeDotTime(m.ExpiryDate),
		Cost:         boilergql.PointerFloat64ToFloat64(m.Cost),
		Weight:       boilergql.PointerFloat64ToFloat64(m.Weight),
		FragranceID:  int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.FragranceID))),
		SupplierID:   int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.SupplierID))),
		DeletedAt:    boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt:    boilergql.PointerIntToTimeDotTime(m.CreatedAt),
		UpdatedAt:    boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
	}
	return r
}

func FragranceInventoryUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.FragranceInventoryUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "purchaseDate":
			modelM[models.FragranceInventoryColumns.PurchaseDate] = boilergql.PointerIntToTimeDotTime(m.PurchaseDate)
		case "expiryDate":
			modelM[models.FragranceInventoryColumns.ExpiryDate] = boilergql.PointerIntToTimeDotTime(m.ExpiryDate)
		case "cost":
			modelM[models.FragranceInventoryColumns.Cost] = boilergql.PointerFloat64ToFloat64(m.Cost)
		case "weight":
			modelM[models.FragranceInventoryColumns.Weight] = boilergql.PointerFloat64ToFloat64(m.Weight)
		case "fragranceId":
			modelM[models.FragranceInventoryColumns.FragranceID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.FragranceID)))
		case "supplierId":
			modelM[models.FragranceInventoryColumns.SupplierID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.SupplierID)))
		case "deletedAt":
			modelM[models.FragranceInventoryColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.FragranceInventoryColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.FragranceInventoryColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		}
	}
	return modelM
}

func FragranceInventoryUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "purchaseDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.PurchaseDate)
		case "expiryDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.ExpiryDate)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.Cost)
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.Weight)
		case "fragranceId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.FragranceID)
		case "supplierId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.SupplierID)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceInventoryColumns.UpdatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func FragranceUpdateInputsToBoiler(am []*gmodels.FragranceUpdateInput) []*models.Fragrance {
	ar := make([]*models.Fragrance, len(am))
	for i, m := range am {
		ar[i] = FragranceUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func FragranceUpdateInputToBoiler(
	m *gmodels.FragranceUpdateInput,
) *models.Fragrance {
	if m == nil {
		return nil
	}
	r := &models.Fragrance{
		Name:      boilergql.PointerStringToString(m.Name),
		Note:      boilergql.PointerStringToString(m.Note),
		CreatedAt: boilergql.PointerIntToTimeDotTime(m.CreatedAt),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
		UpdatedAt: boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
	}
	return r
}

func FragranceUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.FragranceUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "name":
			modelM[models.FragranceColumns.Name] = boilergql.PointerStringToString(m.Name)
		case "note":
			modelM[models.FragranceColumns.Note] = boilergql.PointerStringToString(m.Note)
		case "createdAt":
			modelM[models.FragranceColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		case "deletedAt":
			modelM[models.FragranceColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "updatedAt":
			modelM[models.FragranceColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		}
	}
	return modelM
}

func FragranceUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "name":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceColumns.Name)
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceColumns.Note)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceColumns.CreatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceColumns.DeletedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.FragranceColumns.UpdatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func LipidCreateInputsToBoiler(am []*gmodels.LipidCreateInput) []*models.Lipid {
	ar := make([]*models.Lipid, len(am))
	for i, m := range am {
		ar[i] = LipidCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func LipidCreateInputToBoiler(
	m *gmodels.LipidCreateInput,
) *models.Lipid {
	if m == nil {
		return nil
	}
	r := &models.Lipid{
		Name:             m.Name,
		Lauric:           m.Lauric,
		Myristic:         m.Myristic,
		Palmitic:         m.Palmitic,
		Stearic:          m.Stearic,
		Ricinoleic:       m.Ricinoleic,
		Oleic:            m.Oleic,
		Linoleic:         m.Linoleic,
		Linolenic:        m.Linolenic,
		Hardness:         m.Hardness,
		Cleansing:        m.Cleansing,
		Conditioning:     m.Conditioning,
		Bubbly:           m.Bubbly,
		Creamy:           m.Creamy,
		Iodine:           m.Iodine,
		Ins:              m.Ins,
		InciName:         m.InciName,
		Family:           m.Family,
		Naoh:             m.Naoh,
		DeletedAt:        boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt:        boilergql.IntToTimeDotTime(m.CreatedAt),
		UpdatedAt:        boilergql.IntToTimeDotTime(m.UpdatedAt),
		RecipeBatchLipid: boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeBatchLipid)),
		RecipeLipid:      boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeLipid)),
	}
	return r
}

func LipidCreateInputToModelM(
	input map[string]interface{},
	m gmodels.LipidCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "name":
			modelM[models.LipidColumns.Name] = m.Name
		case "lauric":
			modelM[models.LipidColumns.Lauric] = m.Lauric
		case "myristic":
			modelM[models.LipidColumns.Myristic] = m.Myristic
		case "palmitic":
			modelM[models.LipidColumns.Palmitic] = m.Palmitic
		case "stearic":
			modelM[models.LipidColumns.Stearic] = m.Stearic
		case "ricinoleic":
			modelM[models.LipidColumns.Ricinoleic] = m.Ricinoleic
		case "oleic":
			modelM[models.LipidColumns.Oleic] = m.Oleic
		case "linoleic":
			modelM[models.LipidColumns.Linoleic] = m.Linoleic
		case "linolenic":
			modelM[models.LipidColumns.Linolenic] = m.Linolenic
		case "hardness":
			modelM[models.LipidColumns.Hardness] = m.Hardness
		case "cleansing":
			modelM[models.LipidColumns.Cleansing] = m.Cleansing
		case "conditioning":
			modelM[models.LipidColumns.Conditioning] = m.Conditioning
		case "bubbly":
			modelM[models.LipidColumns.Bubbly] = m.Bubbly
		case "creamy":
			modelM[models.LipidColumns.Creamy] = m.Creamy
		case "iodine":
			modelM[models.LipidColumns.Iodine] = m.Iodine
		case "ins":
			modelM[models.LipidColumns.Ins] = m.Ins
		case "inciName":
			modelM[models.LipidColumns.InciName] = m.InciName
		case "family":
			modelM[models.LipidColumns.Family] = m.Family
		case "naoh":
			modelM[models.LipidColumns.Naoh] = m.Naoh
		case "deletedAt":
			modelM[models.LipidColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.LipidColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.LipidColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		case "recipeBatchLipid":
			modelM[models.LipidColumns.RecipeBatchLipid] = boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeBatchLipid))
		case "recipeLipid":
			modelM[models.LipidColumns.RecipeLipid] = boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeLipid))
		}
	}
	return modelM
}

func LipidCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "name":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Name)
		case "lauric":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Lauric)
		case "myristic":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Myristic)
		case "palmitic":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Palmitic)
		case "stearic":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Stearic)
		case "ricinoleic":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Ricinoleic)
		case "oleic":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Oleic)
		case "linoleic":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Linoleic)
		case "linolenic":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Linolenic)
		case "hardness":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Hardness)
		case "cleansing":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Cleansing)
		case "conditioning":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Conditioning)
		case "bubbly":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Bubbly)
		case "creamy":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Creamy)
		case "iodine":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Iodine)
		case "ins":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Ins)
		case "inciName":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.InciName)
		case "family":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Family)
		case "naoh":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Naoh)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.UpdatedAt)
		case "recipeBatchLipid":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.RecipeBatchLipid)
		case "recipeLipid":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.RecipeLipid)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func LipidInventoryCreateInputsToBoiler(am []*gmodels.LipidInventoryCreateInput) []*models.LipidInventory {
	ar := make([]*models.LipidInventory, len(am))
	for i, m := range am {
		ar[i] = LipidInventoryCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func LipidInventoryCreateInputToBoiler(
	m *gmodels.LipidInventoryCreateInput,
) *models.LipidInventory {
	if m == nil {
		return nil
	}
	r := &models.LipidInventory{
		PurchaseDate:  boilergql.IntToTimeDotTime(m.PurchaseDate),
		ExpiryDate:    boilergql.IntToTimeDotTime(m.ExpiryDate),
		Cost:          m.Cost,
		Weight:        m.Weight,
		Sap:           m.Sap,
		Naoh:          m.Naoh,
		Koh:           m.Koh,
		GramsPerLiter: m.GramsPerLiter,
		LipidID:       int(boilergql.IDToBoiler(m.LipidID)),
		SupplierID:    int(boilergql.IDToBoiler(m.SupplierID)),
		CreatedAt:     boilergql.IntToTimeDotTime(m.CreatedAt),
		DeletedAt:     boilergql.PointerIntToNullDotTime(m.DeletedAt),
		UpdatedAt:     boilergql.IntToTimeDotTime(m.UpdatedAt),
	}
	return r
}

func LipidInventoryCreateInputToModelM(
	input map[string]interface{},
	m gmodels.LipidInventoryCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "purchaseDate":
			modelM[models.LipidInventoryColumns.PurchaseDate] = boilergql.IntToTimeDotTime(m.PurchaseDate)
		case "expiryDate":
			modelM[models.LipidInventoryColumns.ExpiryDate] = boilergql.IntToTimeDotTime(m.ExpiryDate)
		case "cost":
			modelM[models.LipidInventoryColumns.Cost] = m.Cost
		case "weight":
			modelM[models.LipidInventoryColumns.Weight] = m.Weight
		case "sap":
			modelM[models.LipidInventoryColumns.Sap] = m.Sap
		case "naoh":
			modelM[models.LipidInventoryColumns.Naoh] = m.Naoh
		case "koh":
			modelM[models.LipidInventoryColumns.Koh] = m.Koh
		case "gramsPerLiter":
			modelM[models.LipidInventoryColumns.GramsPerLiter] = m.GramsPerLiter
		case "lipidId":
			modelM[models.LipidInventoryColumns.LipidID] = int(boilergql.IDToBoiler(m.LipidID))
		case "supplierId":
			modelM[models.LipidInventoryColumns.SupplierID] = int(boilergql.IDToBoiler(m.SupplierID))
		case "createdAt":
			modelM[models.LipidInventoryColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		case "deletedAt":
			modelM[models.LipidInventoryColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "updatedAt":
			modelM[models.LipidInventoryColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		}
	}
	return modelM
}

func LipidInventoryCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "purchaseDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.PurchaseDate)
		case "expiryDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.ExpiryDate)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.Cost)
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.Weight)
		case "sap":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.Sap)
		case "naoh":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.Naoh)
		case "koh":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.Koh)
		case "gramsPerLiter":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.GramsPerLiter)
		case "lipidId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.LipidID)
		case "supplierId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.SupplierID)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.CreatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.DeletedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.UpdatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func LipidInventoryUpdateInputsToBoiler(am []*gmodels.LipidInventoryUpdateInput) []*models.LipidInventory {
	ar := make([]*models.LipidInventory, len(am))
	for i, m := range am {
		ar[i] = LipidInventoryUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func LipidInventoryUpdateInputToBoiler(
	m *gmodels.LipidInventoryUpdateInput,
) *models.LipidInventory {
	if m == nil {
		return nil
	}
	r := &models.LipidInventory{
		PurchaseDate:  boilergql.PointerIntToTimeDotTime(m.PurchaseDate),
		ExpiryDate:    boilergql.PointerIntToTimeDotTime(m.ExpiryDate),
		Cost:          boilergql.PointerFloat64ToFloat64(m.Cost),
		Weight:        boilergql.PointerFloat64ToFloat64(m.Weight),
		Sap:           boilergql.PointerFloat64ToFloat64(m.Sap),
		Naoh:          boilergql.PointerFloat64ToFloat64(m.Naoh),
		Koh:           boilergql.PointerFloat64ToFloat64(m.Koh),
		GramsPerLiter: boilergql.PointerFloat64ToFloat64(m.GramsPerLiter),
		LipidID:       int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.LipidID))),
		SupplierID:    int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.SupplierID))),
		CreatedAt:     boilergql.PointerIntToTimeDotTime(m.CreatedAt),
		DeletedAt:     boilergql.PointerIntToNullDotTime(m.DeletedAt),
		UpdatedAt:     boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
	}
	return r
}

func LipidInventoryUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.LipidInventoryUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "purchaseDate":
			modelM[models.LipidInventoryColumns.PurchaseDate] = boilergql.PointerIntToTimeDotTime(m.PurchaseDate)
		case "expiryDate":
			modelM[models.LipidInventoryColumns.ExpiryDate] = boilergql.PointerIntToTimeDotTime(m.ExpiryDate)
		case "cost":
			modelM[models.LipidInventoryColumns.Cost] = boilergql.PointerFloat64ToFloat64(m.Cost)
		case "weight":
			modelM[models.LipidInventoryColumns.Weight] = boilergql.PointerFloat64ToFloat64(m.Weight)
		case "sap":
			modelM[models.LipidInventoryColumns.Sap] = boilergql.PointerFloat64ToFloat64(m.Sap)
		case "naoh":
			modelM[models.LipidInventoryColumns.Naoh] = boilergql.PointerFloat64ToFloat64(m.Naoh)
		case "koh":
			modelM[models.LipidInventoryColumns.Koh] = boilergql.PointerFloat64ToFloat64(m.Koh)
		case "gramsPerLiter":
			modelM[models.LipidInventoryColumns.GramsPerLiter] = boilergql.PointerFloat64ToFloat64(m.GramsPerLiter)
		case "lipidId":
			modelM[models.LipidInventoryColumns.LipidID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.LipidID)))
		case "supplierId":
			modelM[models.LipidInventoryColumns.SupplierID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.SupplierID)))
		case "createdAt":
			modelM[models.LipidInventoryColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		case "deletedAt":
			modelM[models.LipidInventoryColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "updatedAt":
			modelM[models.LipidInventoryColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		}
	}
	return modelM
}

func LipidInventoryUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "purchaseDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.PurchaseDate)
		case "expiryDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.ExpiryDate)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.Cost)
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.Weight)
		case "sap":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.Sap)
		case "naoh":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.Naoh)
		case "koh":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.Koh)
		case "gramsPerLiter":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.GramsPerLiter)
		case "lipidId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.LipidID)
		case "supplierId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.SupplierID)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.CreatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.DeletedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidInventoryColumns.UpdatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func LipidUpdateInputsToBoiler(am []*gmodels.LipidUpdateInput) []*models.Lipid {
	ar := make([]*models.Lipid, len(am))
	for i, m := range am {
		ar[i] = LipidUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func LipidUpdateInputToBoiler(
	m *gmodels.LipidUpdateInput,
) *models.Lipid {
	if m == nil {
		return nil
	}
	r := &models.Lipid{
		Name:             boilergql.PointerStringToString(m.Name),
		Lauric:           boilergql.PointerIntToInt(m.Lauric),
		Myristic:         boilergql.PointerIntToInt(m.Myristic),
		Palmitic:         boilergql.PointerIntToInt(m.Palmitic),
		Stearic:          boilergql.PointerIntToInt(m.Stearic),
		Ricinoleic:       boilergql.PointerIntToInt(m.Ricinoleic),
		Oleic:            boilergql.PointerIntToInt(m.Oleic),
		Linoleic:         boilergql.PointerIntToInt(m.Linoleic),
		Linolenic:        boilergql.PointerIntToInt(m.Linolenic),
		Hardness:         boilergql.PointerIntToInt(m.Hardness),
		Cleansing:        boilergql.PointerIntToInt(m.Cleansing),
		Conditioning:     boilergql.PointerIntToInt(m.Conditioning),
		Bubbly:           boilergql.PointerIntToInt(m.Bubbly),
		Creamy:           boilergql.PointerIntToInt(m.Creamy),
		Iodine:           boilergql.PointerIntToInt(m.Iodine),
		Ins:              boilergql.PointerIntToInt(m.Ins),
		InciName:         boilergql.PointerStringToString(m.InciName),
		Family:           boilergql.PointerStringToString(m.Family),
		Naoh:             boilergql.PointerFloat64ToFloat64(m.Naoh),
		DeletedAt:        boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt:        boilergql.PointerIntToTimeDotTime(m.CreatedAt),
		UpdatedAt:        boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
		RecipeBatchLipid: boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeBatchLipid)),
		RecipeLipid:      boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeLipid)),
	}
	return r
}

func LipidUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.LipidUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "name":
			modelM[models.LipidColumns.Name] = boilergql.PointerStringToString(m.Name)
		case "lauric":
			modelM[models.LipidColumns.Lauric] = boilergql.PointerIntToInt(m.Lauric)
		case "myristic":
			modelM[models.LipidColumns.Myristic] = boilergql.PointerIntToInt(m.Myristic)
		case "palmitic":
			modelM[models.LipidColumns.Palmitic] = boilergql.PointerIntToInt(m.Palmitic)
		case "stearic":
			modelM[models.LipidColumns.Stearic] = boilergql.PointerIntToInt(m.Stearic)
		case "ricinoleic":
			modelM[models.LipidColumns.Ricinoleic] = boilergql.PointerIntToInt(m.Ricinoleic)
		case "oleic":
			modelM[models.LipidColumns.Oleic] = boilergql.PointerIntToInt(m.Oleic)
		case "linoleic":
			modelM[models.LipidColumns.Linoleic] = boilergql.PointerIntToInt(m.Linoleic)
		case "linolenic":
			modelM[models.LipidColumns.Linolenic] = boilergql.PointerIntToInt(m.Linolenic)
		case "hardness":
			modelM[models.LipidColumns.Hardness] = boilergql.PointerIntToInt(m.Hardness)
		case "cleansing":
			modelM[models.LipidColumns.Cleansing] = boilergql.PointerIntToInt(m.Cleansing)
		case "conditioning":
			modelM[models.LipidColumns.Conditioning] = boilergql.PointerIntToInt(m.Conditioning)
		case "bubbly":
			modelM[models.LipidColumns.Bubbly] = boilergql.PointerIntToInt(m.Bubbly)
		case "creamy":
			modelM[models.LipidColumns.Creamy] = boilergql.PointerIntToInt(m.Creamy)
		case "iodine":
			modelM[models.LipidColumns.Iodine] = boilergql.PointerIntToInt(m.Iodine)
		case "ins":
			modelM[models.LipidColumns.Ins] = boilergql.PointerIntToInt(m.Ins)
		case "inciName":
			modelM[models.LipidColumns.InciName] = boilergql.PointerStringToString(m.InciName)
		case "family":
			modelM[models.LipidColumns.Family] = boilergql.PointerStringToString(m.Family)
		case "naoh":
			modelM[models.LipidColumns.Naoh] = boilergql.PointerFloat64ToFloat64(m.Naoh)
		case "deletedAt":
			modelM[models.LipidColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.LipidColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.LipidColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		case "recipeBatchLipid":
			modelM[models.LipidColumns.RecipeBatchLipid] = boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeBatchLipid))
		case "recipeLipid":
			modelM[models.LipidColumns.RecipeLipid] = boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeLipid))
		}
	}
	return modelM
}

func LipidUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "name":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Name)
		case "lauric":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Lauric)
		case "myristic":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Myristic)
		case "palmitic":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Palmitic)
		case "stearic":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Stearic)
		case "ricinoleic":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Ricinoleic)
		case "oleic":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Oleic)
		case "linoleic":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Linoleic)
		case "linolenic":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Linolenic)
		case "hardness":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Hardness)
		case "cleansing":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Cleansing)
		case "conditioning":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Conditioning)
		case "bubbly":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Bubbly)
		case "creamy":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Creamy)
		case "iodine":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Iodine)
		case "ins":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Ins)
		case "inciName":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.InciName)
		case "family":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Family)
		case "naoh":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.Naoh)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.UpdatedAt)
		case "recipeBatchLipid":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.RecipeBatchLipid)
		case "recipeLipid":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LipidColumns.RecipeLipid)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func LyeCreateInputsToBoiler(am []*gmodels.LyeCreateInput) []*models.Lye {
	ar := make([]*models.Lye, len(am))
	for i, m := range am {
		ar[i] = LyeCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func LyeCreateInputToBoiler(
	m *gmodels.LyeCreateInput,
) *models.Lye {
	if m == nil {
		return nil
	}
	r := &models.Lye{
		Kind:      m.Kind,
		Name:      m.Name,
		Note:      m.Note,
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
		UpdatedAt: boilergql.IntToTimeDotTime(m.UpdatedAt),
		CreatedAt: boilergql.IntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func LyeCreateInputToModelM(
	input map[string]interface{},
	m gmodels.LyeCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "kind":
			modelM[models.LyeColumns.Kind] = m.Kind
		case "name":
			modelM[models.LyeColumns.Name] = m.Name
		case "note":
			modelM[models.LyeColumns.Note] = m.Note
		case "deletedAt":
			modelM[models.LyeColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "updatedAt":
			modelM[models.LyeColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		case "createdAt":
			modelM[models.LyeColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func LyeCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "kind":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeColumns.Kind)
		case "name":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeColumns.Name)
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeColumns.Note)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeColumns.DeletedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeColumns.UpdatedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func LyeInventoryCreateInputsToBoiler(am []*gmodels.LyeInventoryCreateInput) []*models.LyeInventory {
	ar := make([]*models.LyeInventory, len(am))
	for i, m := range am {
		ar[i] = LyeInventoryCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func LyeInventoryCreateInputToBoiler(
	m *gmodels.LyeInventoryCreateInput,
) *models.LyeInventory {
	if m == nil {
		return nil
	}
	r := &models.LyeInventory{
		PurchaseDate:  boilergql.IntToTimeDotTime(m.PurchaseDate),
		ExpiryDate:    boilergql.IntToTimeDotTime(m.ExpiryDate),
		Cost:          m.Cost,
		Weight:        m.Weight,
		Concentration: m.Concentration,
		LyeID:         int(boilergql.IDToBoiler(m.LyeID)),
		SupplierID:    int(boilergql.IDToBoiler(m.SupplierID)),
		DeletedAt:     boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt:     boilergql.IntToTimeDotTime(m.CreatedAt),
		UpdatedAt:     boilergql.IntToTimeDotTime(m.UpdatedAt),
	}
	return r
}

func LyeInventoryCreateInputToModelM(
	input map[string]interface{},
	m gmodels.LyeInventoryCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "purchaseDate":
			modelM[models.LyeInventoryColumns.PurchaseDate] = boilergql.IntToTimeDotTime(m.PurchaseDate)
		case "expiryDate":
			modelM[models.LyeInventoryColumns.ExpiryDate] = boilergql.IntToTimeDotTime(m.ExpiryDate)
		case "cost":
			modelM[models.LyeInventoryColumns.Cost] = m.Cost
		case "weight":
			modelM[models.LyeInventoryColumns.Weight] = m.Weight
		case "concentration":
			modelM[models.LyeInventoryColumns.Concentration] = m.Concentration
		case "lyeId":
			modelM[models.LyeInventoryColumns.LyeID] = int(boilergql.IDToBoiler(m.LyeID))
		case "supplierId":
			modelM[models.LyeInventoryColumns.SupplierID] = int(boilergql.IDToBoiler(m.SupplierID))
		case "deletedAt":
			modelM[models.LyeInventoryColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.LyeInventoryColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.LyeInventoryColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		}
	}
	return modelM
}

func LyeInventoryCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "purchaseDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.PurchaseDate)
		case "expiryDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.ExpiryDate)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.Cost)
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.Weight)
		case "concentration":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.Concentration)
		case "lyeId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.LyeID)
		case "supplierId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.SupplierID)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.UpdatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func LyeInventoryUpdateInputsToBoiler(am []*gmodels.LyeInventoryUpdateInput) []*models.LyeInventory {
	ar := make([]*models.LyeInventory, len(am))
	for i, m := range am {
		ar[i] = LyeInventoryUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func LyeInventoryUpdateInputToBoiler(
	m *gmodels.LyeInventoryUpdateInput,
) *models.LyeInventory {
	if m == nil {
		return nil
	}
	r := &models.LyeInventory{
		PurchaseDate:  boilergql.PointerIntToTimeDotTime(m.PurchaseDate),
		ExpiryDate:    boilergql.PointerIntToTimeDotTime(m.ExpiryDate),
		Cost:          boilergql.PointerFloat64ToFloat64(m.Cost),
		Weight:        boilergql.PointerFloat64ToFloat64(m.Weight),
		Concentration: boilergql.PointerFloat64ToFloat64(m.Concentration),
		LyeID:         int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.LyeID))),
		SupplierID:    int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.SupplierID))),
		DeletedAt:     boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt:     boilergql.PointerIntToTimeDotTime(m.CreatedAt),
		UpdatedAt:     boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
	}
	return r
}

func LyeInventoryUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.LyeInventoryUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "purchaseDate":
			modelM[models.LyeInventoryColumns.PurchaseDate] = boilergql.PointerIntToTimeDotTime(m.PurchaseDate)
		case "expiryDate":
			modelM[models.LyeInventoryColumns.ExpiryDate] = boilergql.PointerIntToTimeDotTime(m.ExpiryDate)
		case "cost":
			modelM[models.LyeInventoryColumns.Cost] = boilergql.PointerFloat64ToFloat64(m.Cost)
		case "weight":
			modelM[models.LyeInventoryColumns.Weight] = boilergql.PointerFloat64ToFloat64(m.Weight)
		case "concentration":
			modelM[models.LyeInventoryColumns.Concentration] = boilergql.PointerFloat64ToFloat64(m.Concentration)
		case "lyeId":
			modelM[models.LyeInventoryColumns.LyeID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.LyeID)))
		case "supplierId":
			modelM[models.LyeInventoryColumns.SupplierID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.SupplierID)))
		case "deletedAt":
			modelM[models.LyeInventoryColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.LyeInventoryColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.LyeInventoryColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		}
	}
	return modelM
}

func LyeInventoryUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "purchaseDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.PurchaseDate)
		case "expiryDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.ExpiryDate)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.Cost)
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.Weight)
		case "concentration":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.Concentration)
		case "lyeId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.LyeID)
		case "supplierId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.SupplierID)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeInventoryColumns.UpdatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func LyeUpdateInputsToBoiler(am []*gmodels.LyeUpdateInput) []*models.Lye {
	ar := make([]*models.Lye, len(am))
	for i, m := range am {
		ar[i] = LyeUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func LyeUpdateInputToBoiler(
	m *gmodels.LyeUpdateInput,
) *models.Lye {
	if m == nil {
		return nil
	}
	r := &models.Lye{
		Kind:      boilergql.PointerStringToString(m.Kind),
		Name:      boilergql.PointerStringToString(m.Name),
		Note:      boilergql.PointerStringToString(m.Note),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
		UpdatedAt: boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
		CreatedAt: boilergql.PointerIntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func LyeUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.LyeUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "kind":
			modelM[models.LyeColumns.Kind] = boilergql.PointerStringToString(m.Kind)
		case "name":
			modelM[models.LyeColumns.Name] = boilergql.PointerStringToString(m.Name)
		case "note":
			modelM[models.LyeColumns.Note] = boilergql.PointerStringToString(m.Note)
		case "deletedAt":
			modelM[models.LyeColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "updatedAt":
			modelM[models.LyeColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		case "createdAt":
			modelM[models.LyeColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func LyeUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "kind":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeColumns.Kind)
		case "name":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeColumns.Name)
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeColumns.Note)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeColumns.DeletedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeColumns.UpdatedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.LyeColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeAdditiveCreateInputsToBoiler(am []*gmodels.RecipeAdditiveCreateInput) []*models.RecipeAdditive {
	ar := make([]*models.RecipeAdditive, len(am))
	for i, m := range am {
		ar[i] = RecipeAdditiveCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeAdditiveCreateInputToBoiler(
	m *gmodels.RecipeAdditiveCreateInput,
) *models.RecipeAdditive {
	if m == nil {
		return nil
	}
	r := &models.RecipeAdditive{
		Percentage: m.Percentage,
		AdditiveID: int(boilergql.IDToBoiler(m.AdditiveID)),
		RecipeID:   int(boilergql.IDToBoiler(m.RecipeID)),
		DeletedAt:  boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt:  boilergql.IntToTimeDotTime(m.CreatedAt),
		UpdatedAt:  boilergql.IntToTimeDotTime(m.UpdatedAt),
	}
	return r
}

func RecipeAdditiveCreateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeAdditiveCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "percentage":
			modelM[models.RecipeAdditiveColumns.Percentage] = m.Percentage
		case "additiveId":
			modelM[models.RecipeAdditiveColumns.AdditiveID] = int(boilergql.IDToBoiler(m.AdditiveID))
		case "recipeId":
			modelM[models.RecipeAdditiveColumns.RecipeID] = int(boilergql.IDToBoiler(m.RecipeID))
		case "deletedAt":
			modelM[models.RecipeAdditiveColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.RecipeAdditiveColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.RecipeAdditiveColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		}
	}
	return modelM
}

func RecipeAdditiveCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "percentage":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeAdditiveColumns.Percentage)
		case "additiveId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeAdditiveColumns.AdditiveID)
		case "recipeId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeAdditiveColumns.RecipeID)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeAdditiveColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeAdditiveColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeAdditiveColumns.UpdatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeAdditiveUpdateInputsToBoiler(am []*gmodels.RecipeAdditiveUpdateInput) []*models.RecipeAdditive {
	ar := make([]*models.RecipeAdditive, len(am))
	for i, m := range am {
		ar[i] = RecipeAdditiveUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeAdditiveUpdateInputToBoiler(
	m *gmodels.RecipeAdditiveUpdateInput,
) *models.RecipeAdditive {
	if m == nil {
		return nil
	}
	r := &models.RecipeAdditive{
		Percentage: boilergql.PointerFloat64ToFloat64(m.Percentage),
		AdditiveID: int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.AdditiveID))),
		RecipeID:   int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeID))),
		DeletedAt:  boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt:  boilergql.PointerIntToTimeDotTime(m.CreatedAt),
		UpdatedAt:  boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
	}
	return r
}

func RecipeAdditiveUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeAdditiveUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "percentage":
			modelM[models.RecipeAdditiveColumns.Percentage] = boilergql.PointerFloat64ToFloat64(m.Percentage)
		case "additiveId":
			modelM[models.RecipeAdditiveColumns.AdditiveID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.AdditiveID)))
		case "recipeId":
			modelM[models.RecipeAdditiveColumns.RecipeID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeID)))
		case "deletedAt":
			modelM[models.RecipeAdditiveColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.RecipeAdditiveColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.RecipeAdditiveColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		}
	}
	return modelM
}

func RecipeAdditiveUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "percentage":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeAdditiveColumns.Percentage)
		case "additiveId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeAdditiveColumns.AdditiveID)
		case "recipeId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeAdditiveColumns.RecipeID)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeAdditiveColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeAdditiveColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeAdditiveColumns.UpdatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeBatchAdditiveCreateInputsToBoiler(am []*gmodels.RecipeBatchAdditiveCreateInput) []*models.RecipeBatchAdditive {
	ar := make([]*models.RecipeBatchAdditive, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchAdditiveCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeBatchAdditiveCreateInputToBoiler(
	m *gmodels.RecipeBatchAdditiveCreateInput,
) *models.RecipeBatchAdditive {
	if m == nil {
		return nil
	}
	r := &models.RecipeBatchAdditive{
		Weight:     m.Weight,
		Cost:       m.Cost,
		AdditiveID: int(boilergql.IDToBoiler(m.AdditiveID)),
		BatchID:    int(boilergql.IDToBoiler(m.BatchID)),
		CreatedAt:  boilergql.IntToTimeDotTime(m.CreatedAt),
		UpdatedAt:  boilergql.IntToTimeDotTime(m.UpdatedAt),
		DeletedAt:  boilergql.PointerIntToNullDotTime(m.DeletedAt),
	}
	return r
}

func RecipeBatchAdditiveCreateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeBatchAdditiveCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "weight":
			modelM[models.RecipeBatchAdditiveColumns.Weight] = m.Weight
		case "cost":
			modelM[models.RecipeBatchAdditiveColumns.Cost] = m.Cost
		case "additiveId":
			modelM[models.RecipeBatchAdditiveColumns.AdditiveID] = int(boilergql.IDToBoiler(m.AdditiveID))
		case "batchId":
			modelM[models.RecipeBatchAdditiveColumns.BatchID] = int(boilergql.IDToBoiler(m.BatchID))
		case "createdAt":
			modelM[models.RecipeBatchAdditiveColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.RecipeBatchAdditiveColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		case "deletedAt":
			modelM[models.RecipeBatchAdditiveColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		}
	}
	return modelM
}

func RecipeBatchAdditiveCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchAdditiveColumns.Weight)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchAdditiveColumns.Cost)
		case "additiveId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchAdditiveColumns.AdditiveID)
		case "batchId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchAdditiveColumns.BatchID)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchAdditiveColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchAdditiveColumns.UpdatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchAdditiveColumns.DeletedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeBatchAdditiveUpdateInputsToBoiler(am []*gmodels.RecipeBatchAdditiveUpdateInput) []*models.RecipeBatchAdditive {
	ar := make([]*models.RecipeBatchAdditive, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchAdditiveUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeBatchAdditiveUpdateInputToBoiler(
	m *gmodels.RecipeBatchAdditiveUpdateInput,
) *models.RecipeBatchAdditive {
	if m == nil {
		return nil
	}
	r := &models.RecipeBatchAdditive{
		Weight:     boilergql.PointerFloat64ToFloat64(m.Weight),
		Cost:       boilergql.PointerFloat64ToFloat64(m.Cost),
		AdditiveID: int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.AdditiveID))),
		BatchID:    int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.BatchID))),
		CreatedAt:  boilergql.PointerIntToTimeDotTime(m.CreatedAt),
		UpdatedAt:  boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
		DeletedAt:  boilergql.PointerIntToNullDotTime(m.DeletedAt),
	}
	return r
}

func RecipeBatchAdditiveUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeBatchAdditiveUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "weight":
			modelM[models.RecipeBatchAdditiveColumns.Weight] = boilergql.PointerFloat64ToFloat64(m.Weight)
		case "cost":
			modelM[models.RecipeBatchAdditiveColumns.Cost] = boilergql.PointerFloat64ToFloat64(m.Cost)
		case "additiveId":
			modelM[models.RecipeBatchAdditiveColumns.AdditiveID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.AdditiveID)))
		case "batchId":
			modelM[models.RecipeBatchAdditiveColumns.BatchID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.BatchID)))
		case "createdAt":
			modelM[models.RecipeBatchAdditiveColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.RecipeBatchAdditiveColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		case "deletedAt":
			modelM[models.RecipeBatchAdditiveColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		}
	}
	return modelM
}

func RecipeBatchAdditiveUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchAdditiveColumns.Weight)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchAdditiveColumns.Cost)
		case "additiveId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchAdditiveColumns.AdditiveID)
		case "batchId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchAdditiveColumns.BatchID)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchAdditiveColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchAdditiveColumns.UpdatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchAdditiveColumns.DeletedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeBatchCreateInputsToBoiler(am []*gmodels.RecipeBatchCreateInput) []*models.RecipeBatch {
	ar := make([]*models.RecipeBatch, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeBatchCreateInputToBoiler(
	m *gmodels.RecipeBatchCreateInput,
) *models.RecipeBatch {
	if m == nil {
		return nil
	}
	r := &models.RecipeBatch{
		Tag:              m.Tag,
		ProductionDate:   boilergql.IntToTimeDotTime(m.ProductionDate),
		SellableDate:     boilergql.IntToTimeDotTime(m.SellableDate),
		Note:             m.Note,
		LipidWeight:      m.LipidWeight,
		ProductionWeight: m.ProductionWeight,
		CuredWeight:      m.CuredWeight,
		RecipeID:         int(boilergql.IDToBoiler(m.RecipeID)),
		DeletedAt:        boilergql.PointerIntToNullDotTime(m.DeletedAt),
		UpdatedAt:        boilergql.IntToTimeDotTime(m.UpdatedAt),
		CreatedAt:        boilergql.IntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func RecipeBatchCreateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeBatchCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "tag":
			modelM[models.RecipeBatchColumns.Tag] = m.Tag
		case "productionDate":
			modelM[models.RecipeBatchColumns.ProductionDate] = boilergql.IntToTimeDotTime(m.ProductionDate)
		case "sellableDate":
			modelM[models.RecipeBatchColumns.SellableDate] = boilergql.IntToTimeDotTime(m.SellableDate)
		case "note":
			modelM[models.RecipeBatchColumns.Note] = m.Note
		case "lipidWeight":
			modelM[models.RecipeBatchColumns.LipidWeight] = m.LipidWeight
		case "productionWeight":
			modelM[models.RecipeBatchColumns.ProductionWeight] = m.ProductionWeight
		case "curedWeight":
			modelM[models.RecipeBatchColumns.CuredWeight] = m.CuredWeight
		case "recipeId":
			modelM[models.RecipeBatchColumns.RecipeID] = int(boilergql.IDToBoiler(m.RecipeID))
		case "deletedAt":
			modelM[models.RecipeBatchColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "updatedAt":
			modelM[models.RecipeBatchColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		case "createdAt":
			modelM[models.RecipeBatchColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func RecipeBatchCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "tag":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.Tag)
		case "productionDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.ProductionDate)
		case "sellableDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.SellableDate)
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.Note)
		case "lipidWeight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.LipidWeight)
		case "productionWeight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.ProductionWeight)
		case "curedWeight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.CuredWeight)
		case "recipeId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.RecipeID)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.DeletedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.UpdatedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeBatchFragranceCreateInputsToBoiler(am []*gmodels.RecipeBatchFragranceCreateInput) []*models.RecipeBatchFragrance {
	ar := make([]*models.RecipeBatchFragrance, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchFragranceCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeBatchFragranceCreateInputToBoiler(
	m *gmodels.RecipeBatchFragranceCreateInput,
) *models.RecipeBatchFragrance {
	if m == nil {
		return nil
	}
	r := &models.RecipeBatchFragrance{
		Weight:      m.Weight,
		Cost:        m.Cost,
		FragranceID: int(boilergql.IDToBoiler(m.FragranceID)),
		BatchID:     int(boilergql.IDToBoiler(m.BatchID)),
		UpdatedAt:   boilergql.IntToTimeDotTime(m.UpdatedAt),
		DeletedAt:   boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt:   boilergql.IntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func RecipeBatchFragranceCreateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeBatchFragranceCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "weight":
			modelM[models.RecipeBatchFragranceColumns.Weight] = m.Weight
		case "cost":
			modelM[models.RecipeBatchFragranceColumns.Cost] = m.Cost
		case "fragranceId":
			modelM[models.RecipeBatchFragranceColumns.FragranceID] = int(boilergql.IDToBoiler(m.FragranceID))
		case "batchId":
			modelM[models.RecipeBatchFragranceColumns.BatchID] = int(boilergql.IDToBoiler(m.BatchID))
		case "updatedAt":
			modelM[models.RecipeBatchFragranceColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		case "deletedAt":
			modelM[models.RecipeBatchFragranceColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.RecipeBatchFragranceColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func RecipeBatchFragranceCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchFragranceColumns.Weight)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchFragranceColumns.Cost)
		case "fragranceId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchFragranceColumns.FragranceID)
		case "batchId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchFragranceColumns.BatchID)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchFragranceColumns.UpdatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchFragranceColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchFragranceColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeBatchFragranceUpdateInputsToBoiler(am []*gmodels.RecipeBatchFragranceUpdateInput) []*models.RecipeBatchFragrance {
	ar := make([]*models.RecipeBatchFragrance, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchFragranceUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeBatchFragranceUpdateInputToBoiler(
	m *gmodels.RecipeBatchFragranceUpdateInput,
) *models.RecipeBatchFragrance {
	if m == nil {
		return nil
	}
	r := &models.RecipeBatchFragrance{
		Weight:      boilergql.PointerFloat64ToFloat64(m.Weight),
		Cost:        boilergql.PointerFloat64ToFloat64(m.Cost),
		FragranceID: int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.FragranceID))),
		BatchID:     int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.BatchID))),
		UpdatedAt:   boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
		DeletedAt:   boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt:   boilergql.PointerIntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func RecipeBatchFragranceUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeBatchFragranceUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "weight":
			modelM[models.RecipeBatchFragranceColumns.Weight] = boilergql.PointerFloat64ToFloat64(m.Weight)
		case "cost":
			modelM[models.RecipeBatchFragranceColumns.Cost] = boilergql.PointerFloat64ToFloat64(m.Cost)
		case "fragranceId":
			modelM[models.RecipeBatchFragranceColumns.FragranceID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.FragranceID)))
		case "batchId":
			modelM[models.RecipeBatchFragranceColumns.BatchID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.BatchID)))
		case "updatedAt":
			modelM[models.RecipeBatchFragranceColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		case "deletedAt":
			modelM[models.RecipeBatchFragranceColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.RecipeBatchFragranceColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func RecipeBatchFragranceUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchFragranceColumns.Weight)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchFragranceColumns.Cost)
		case "fragranceId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchFragranceColumns.FragranceID)
		case "batchId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchFragranceColumns.BatchID)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchFragranceColumns.UpdatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchFragranceColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchFragranceColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeBatchLipidCreateInputsToBoiler(am []*gmodels.RecipeBatchLipidCreateInput) []*models.RecipeBatchLipid {
	ar := make([]*models.RecipeBatchLipid, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchLipidCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeBatchLipidCreateInputToBoiler(
	m *gmodels.RecipeBatchLipidCreateInput,
) *models.RecipeBatchLipid {
	if m == nil {
		return nil
	}
	r := &models.RecipeBatchLipid{
		Weight:    m.Weight,
		Cost:      m.Cost,
		LipidID:   int(boilergql.IDToBoiler(m.LipidID)),
		BatchID:   int(boilergql.IDToBoiler(m.BatchID)),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
		UpdatedAt: boilergql.IntToTimeDotTime(m.UpdatedAt),
		CreatedAt: boilergql.IntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func RecipeBatchLipidCreateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeBatchLipidCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "weight":
			modelM[models.RecipeBatchLipidColumns.Weight] = m.Weight
		case "cost":
			modelM[models.RecipeBatchLipidColumns.Cost] = m.Cost
		case "lipidId":
			modelM[models.RecipeBatchLipidColumns.LipidID] = int(boilergql.IDToBoiler(m.LipidID))
		case "batchId":
			modelM[models.RecipeBatchLipidColumns.BatchID] = int(boilergql.IDToBoiler(m.BatchID))
		case "deletedAt":
			modelM[models.RecipeBatchLipidColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "updatedAt":
			modelM[models.RecipeBatchLipidColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		case "createdAt":
			modelM[models.RecipeBatchLipidColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func RecipeBatchLipidCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLipidColumns.Weight)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLipidColumns.Cost)
		case "lipidId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLipidColumns.LipidID)
		case "batchId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLipidColumns.BatchID)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLipidColumns.DeletedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLipidColumns.UpdatedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLipidColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeBatchLipidUpdateInputsToBoiler(am []*gmodels.RecipeBatchLipidUpdateInput) []*models.RecipeBatchLipid {
	ar := make([]*models.RecipeBatchLipid, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchLipidUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeBatchLipidUpdateInputToBoiler(
	m *gmodels.RecipeBatchLipidUpdateInput,
) *models.RecipeBatchLipid {
	if m == nil {
		return nil
	}
	r := &models.RecipeBatchLipid{
		Weight:    boilergql.PointerFloat64ToFloat64(m.Weight),
		Cost:      boilergql.PointerFloat64ToFloat64(m.Cost),
		LipidID:   int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.LipidID))),
		BatchID:   int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.BatchID))),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
		UpdatedAt: boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
		CreatedAt: boilergql.PointerIntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func RecipeBatchLipidUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeBatchLipidUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "weight":
			modelM[models.RecipeBatchLipidColumns.Weight] = boilergql.PointerFloat64ToFloat64(m.Weight)
		case "cost":
			modelM[models.RecipeBatchLipidColumns.Cost] = boilergql.PointerFloat64ToFloat64(m.Cost)
		case "lipidId":
			modelM[models.RecipeBatchLipidColumns.LipidID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.LipidID)))
		case "batchId":
			modelM[models.RecipeBatchLipidColumns.BatchID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.BatchID)))
		case "deletedAt":
			modelM[models.RecipeBatchLipidColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "updatedAt":
			modelM[models.RecipeBatchLipidColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		case "createdAt":
			modelM[models.RecipeBatchLipidColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func RecipeBatchLipidUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLipidColumns.Weight)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLipidColumns.Cost)
		case "lipidId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLipidColumns.LipidID)
		case "batchId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLipidColumns.BatchID)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLipidColumns.DeletedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLipidColumns.UpdatedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLipidColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeBatchLyeCreateInputsToBoiler(am []*gmodels.RecipeBatchLyeCreateInput) []*models.RecipeBatchLye {
	ar := make([]*models.RecipeBatchLye, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchLyeCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeBatchLyeCreateInputToBoiler(
	m *gmodels.RecipeBatchLyeCreateInput,
) *models.RecipeBatchLye {
	if m == nil {
		return nil
	}
	r := &models.RecipeBatchLye{
		Weight:    m.Weight,
		Discount:  m.Discount,
		Cost:      m.Cost,
		LyeID:     int(boilergql.IDToBoiler(m.LyeID)),
		BatchID:   int(boilergql.IDToBoiler(m.BatchID)),
		UpdatedAt: boilergql.IntToTimeDotTime(m.UpdatedAt),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt: boilergql.IntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func RecipeBatchLyeCreateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeBatchLyeCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "weight":
			modelM[models.RecipeBatchLyeColumns.Weight] = m.Weight
		case "discount":
			modelM[models.RecipeBatchLyeColumns.Discount] = m.Discount
		case "cost":
			modelM[models.RecipeBatchLyeColumns.Cost] = m.Cost
		case "lyeId":
			modelM[models.RecipeBatchLyeColumns.LyeID] = int(boilergql.IDToBoiler(m.LyeID))
		case "batchId":
			modelM[models.RecipeBatchLyeColumns.BatchID] = int(boilergql.IDToBoiler(m.BatchID))
		case "updatedAt":
			modelM[models.RecipeBatchLyeColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		case "deletedAt":
			modelM[models.RecipeBatchLyeColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.RecipeBatchLyeColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func RecipeBatchLyeCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.Weight)
		case "discount":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.Discount)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.Cost)
		case "lyeId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.LyeID)
		case "batchId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.BatchID)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.UpdatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeBatchLyeUpdateInputsToBoiler(am []*gmodels.RecipeBatchLyeUpdateInput) []*models.RecipeBatchLye {
	ar := make([]*models.RecipeBatchLye, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchLyeUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeBatchLyeUpdateInputToBoiler(
	m *gmodels.RecipeBatchLyeUpdateInput,
) *models.RecipeBatchLye {
	if m == nil {
		return nil
	}
	r := &models.RecipeBatchLye{
		Weight:    boilergql.PointerFloat64ToFloat64(m.Weight),
		Discount:  boilergql.PointerFloat64ToFloat64(m.Discount),
		Cost:      boilergql.PointerFloat64ToFloat64(m.Cost),
		LyeID:     int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.LyeID))),
		BatchID:   int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.BatchID))),
		UpdatedAt: boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt: boilergql.PointerIntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func RecipeBatchLyeUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeBatchLyeUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "weight":
			modelM[models.RecipeBatchLyeColumns.Weight] = boilergql.PointerFloat64ToFloat64(m.Weight)
		case "discount":
			modelM[models.RecipeBatchLyeColumns.Discount] = boilergql.PointerFloat64ToFloat64(m.Discount)
		case "cost":
			modelM[models.RecipeBatchLyeColumns.Cost] = boilergql.PointerFloat64ToFloat64(m.Cost)
		case "lyeId":
			modelM[models.RecipeBatchLyeColumns.LyeID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.LyeID)))
		case "batchId":
			modelM[models.RecipeBatchLyeColumns.BatchID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.BatchID)))
		case "updatedAt":
			modelM[models.RecipeBatchLyeColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		case "deletedAt":
			modelM[models.RecipeBatchLyeColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.RecipeBatchLyeColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func RecipeBatchLyeUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "weight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.Weight)
		case "discount":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.Discount)
		case "cost":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.Cost)
		case "lyeId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.LyeID)
		case "batchId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.BatchID)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.UpdatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchLyeColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeBatchNoteCreateInputsToBoiler(am []*gmodels.RecipeBatchNoteCreateInput) []*models.RecipeBatchNote {
	ar := make([]*models.RecipeBatchNote, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchNoteCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeBatchNoteCreateInputToBoiler(
	m *gmodels.RecipeBatchNoteCreateInput,
) *models.RecipeBatchNote {
	if m == nil {
		return nil
	}
	r := &models.RecipeBatchNote{
		Note:      m.Note,
		Link:      m.Link,
		BatchID:   int(boilergql.IDToBoiler(m.BatchID)),
		CreatedAt: boilergql.IntToTimeDotTime(m.CreatedAt),
		UpdatedAt: boilergql.IntToTimeDotTime(m.UpdatedAt),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
	}
	return r
}

func RecipeBatchNoteCreateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeBatchNoteCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "note":
			modelM[models.RecipeBatchNoteColumns.Note] = m.Note
		case "link":
			modelM[models.RecipeBatchNoteColumns.Link] = m.Link
		case "batchId":
			modelM[models.RecipeBatchNoteColumns.BatchID] = int(boilergql.IDToBoiler(m.BatchID))
		case "createdAt":
			modelM[models.RecipeBatchNoteColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.RecipeBatchNoteColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		case "deletedAt":
			modelM[models.RecipeBatchNoteColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		}
	}
	return modelM
}

func RecipeBatchNoteCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchNoteColumns.Note)
		case "link":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchNoteColumns.Link)
		case "batchId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchNoteColumns.BatchID)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchNoteColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchNoteColumns.UpdatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchNoteColumns.DeletedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeBatchNoteUpdateInputsToBoiler(am []*gmodels.RecipeBatchNoteUpdateInput) []*models.RecipeBatchNote {
	ar := make([]*models.RecipeBatchNote, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchNoteUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeBatchNoteUpdateInputToBoiler(
	m *gmodels.RecipeBatchNoteUpdateInput,
) *models.RecipeBatchNote {
	if m == nil {
		return nil
	}
	r := &models.RecipeBatchNote{
		Note:      boilergql.PointerStringToString(m.Note),
		Link:      boilergql.PointerStringToString(m.Link),
		BatchID:   int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.BatchID))),
		CreatedAt: boilergql.PointerIntToTimeDotTime(m.CreatedAt),
		UpdatedAt: boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
	}
	return r
}

func RecipeBatchNoteUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeBatchNoteUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "note":
			modelM[models.RecipeBatchNoteColumns.Note] = boilergql.PointerStringToString(m.Note)
		case "link":
			modelM[models.RecipeBatchNoteColumns.Link] = boilergql.PointerStringToString(m.Link)
		case "batchId":
			modelM[models.RecipeBatchNoteColumns.BatchID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.BatchID)))
		case "createdAt":
			modelM[models.RecipeBatchNoteColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.RecipeBatchNoteColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		case "deletedAt":
			modelM[models.RecipeBatchNoteColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		}
	}
	return modelM
}

func RecipeBatchNoteUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchNoteColumns.Note)
		case "link":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchNoteColumns.Link)
		case "batchId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchNoteColumns.BatchID)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchNoteColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchNoteColumns.UpdatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchNoteColumns.DeletedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeBatchUpdateInputsToBoiler(am []*gmodels.RecipeBatchUpdateInput) []*models.RecipeBatch {
	ar := make([]*models.RecipeBatch, len(am))
	for i, m := range am {
		ar[i] = RecipeBatchUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeBatchUpdateInputToBoiler(
	m *gmodels.RecipeBatchUpdateInput,
) *models.RecipeBatch {
	if m == nil {
		return nil
	}
	r := &models.RecipeBatch{
		Tag:              boilergql.PointerStringToString(m.Tag),
		ProductionDate:   boilergql.PointerIntToTimeDotTime(m.ProductionDate),
		SellableDate:     boilergql.PointerIntToTimeDotTime(m.SellableDate),
		Note:             boilergql.PointerStringToString(m.Note),
		LipidWeight:      boilergql.PointerFloat64ToFloat64(m.LipidWeight),
		ProductionWeight: boilergql.PointerFloat64ToFloat64(m.ProductionWeight),
		CuredWeight:      boilergql.PointerFloat64ToFloat64(m.CuredWeight),
		RecipeID:         int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeID))),
		DeletedAt:        boilergql.PointerIntToNullDotTime(m.DeletedAt),
		UpdatedAt:        boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
		CreatedAt:        boilergql.PointerIntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func RecipeBatchUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeBatchUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "tag":
			modelM[models.RecipeBatchColumns.Tag] = boilergql.PointerStringToString(m.Tag)
		case "productionDate":
			modelM[models.RecipeBatchColumns.ProductionDate] = boilergql.PointerIntToTimeDotTime(m.ProductionDate)
		case "sellableDate":
			modelM[models.RecipeBatchColumns.SellableDate] = boilergql.PointerIntToTimeDotTime(m.SellableDate)
		case "note":
			modelM[models.RecipeBatchColumns.Note] = boilergql.PointerStringToString(m.Note)
		case "lipidWeight":
			modelM[models.RecipeBatchColumns.LipidWeight] = boilergql.PointerFloat64ToFloat64(m.LipidWeight)
		case "productionWeight":
			modelM[models.RecipeBatchColumns.ProductionWeight] = boilergql.PointerFloat64ToFloat64(m.ProductionWeight)
		case "curedWeight":
			modelM[models.RecipeBatchColumns.CuredWeight] = boilergql.PointerFloat64ToFloat64(m.CuredWeight)
		case "recipeId":
			modelM[models.RecipeBatchColumns.RecipeID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeID)))
		case "deletedAt":
			modelM[models.RecipeBatchColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "updatedAt":
			modelM[models.RecipeBatchColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		case "createdAt":
			modelM[models.RecipeBatchColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func RecipeBatchUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "tag":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.Tag)
		case "productionDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.ProductionDate)
		case "sellableDate":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.SellableDate)
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.Note)
		case "lipidWeight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.LipidWeight)
		case "productionWeight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.ProductionWeight)
		case "curedWeight":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.CuredWeight)
		case "recipeId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.RecipeID)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.DeletedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.UpdatedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeBatchColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeCreateInputsToBoiler(am []*gmodels.RecipeCreateInput) []*models.Recipe {
	ar := make([]*models.Recipe, len(am))
	for i, m := range am {
		ar[i] = RecipeCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeCreateInputToBoiler(
	m *gmodels.RecipeCreateInput,
) *models.Recipe {
	if m == nil {
		return nil
	}
	r := &models.Recipe{
		Name:      m.Name,
		Note:      m.Note,
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt: boilergql.IntToTimeDotTime(m.CreatedAt),
		UpdatedAt: boilergql.IntToTimeDotTime(m.UpdatedAt),
	}
	return r
}

func RecipeCreateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "name":
			modelM[models.RecipeColumns.Name] = m.Name
		case "note":
			modelM[models.RecipeColumns.Note] = m.Note
		case "deletedAt":
			modelM[models.RecipeColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.RecipeColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.RecipeColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		}
	}
	return modelM
}

func RecipeCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "name":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeColumns.Name)
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeColumns.Note)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeColumns.UpdatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeFragranceCreateInputsToBoiler(am []*gmodels.RecipeFragranceCreateInput) []*models.RecipeFragrance {
	ar := make([]*models.RecipeFragrance, len(am))
	for i, m := range am {
		ar[i] = RecipeFragranceCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeFragranceCreateInputToBoiler(
	m *gmodels.RecipeFragranceCreateInput,
) *models.RecipeFragrance {
	if m == nil {
		return nil
	}
	r := &models.RecipeFragrance{
		Percentage:  m.Percentage,
		FragranceID: int(boilergql.IDToBoiler(m.FragranceID)),
		RecipeID:    int(boilergql.IDToBoiler(m.RecipeID)),
		DeletedAt:   boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt:   boilergql.IntToTimeDotTime(m.CreatedAt),
		UpdatedAt:   boilergql.IntToTimeDotTime(m.UpdatedAt),
	}
	return r
}

func RecipeFragranceCreateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeFragranceCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "percentage":
			modelM[models.RecipeFragranceColumns.Percentage] = m.Percentage
		case "fragranceId":
			modelM[models.RecipeFragranceColumns.FragranceID] = int(boilergql.IDToBoiler(m.FragranceID))
		case "recipeId":
			modelM[models.RecipeFragranceColumns.RecipeID] = int(boilergql.IDToBoiler(m.RecipeID))
		case "deletedAt":
			modelM[models.RecipeFragranceColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.RecipeFragranceColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.RecipeFragranceColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		}
	}
	return modelM
}

func RecipeFragranceCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "percentage":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeFragranceColumns.Percentage)
		case "fragranceId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeFragranceColumns.FragranceID)
		case "recipeId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeFragranceColumns.RecipeID)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeFragranceColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeFragranceColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeFragranceColumns.UpdatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeFragranceUpdateInputsToBoiler(am []*gmodels.RecipeFragranceUpdateInput) []*models.RecipeFragrance {
	ar := make([]*models.RecipeFragrance, len(am))
	for i, m := range am {
		ar[i] = RecipeFragranceUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeFragranceUpdateInputToBoiler(
	m *gmodels.RecipeFragranceUpdateInput,
) *models.RecipeFragrance {
	if m == nil {
		return nil
	}
	r := &models.RecipeFragrance{
		Percentage:  boilergql.PointerFloat64ToFloat64(m.Percentage),
		FragranceID: int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.FragranceID))),
		RecipeID:    int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeID))),
		DeletedAt:   boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt:   boilergql.PointerIntToTimeDotTime(m.CreatedAt),
		UpdatedAt:   boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
	}
	return r
}

func RecipeFragranceUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeFragranceUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "percentage":
			modelM[models.RecipeFragranceColumns.Percentage] = boilergql.PointerFloat64ToFloat64(m.Percentage)
		case "fragranceId":
			modelM[models.RecipeFragranceColumns.FragranceID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.FragranceID)))
		case "recipeId":
			modelM[models.RecipeFragranceColumns.RecipeID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeID)))
		case "deletedAt":
			modelM[models.RecipeFragranceColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.RecipeFragranceColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.RecipeFragranceColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		}
	}
	return modelM
}

func RecipeFragranceUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "percentage":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeFragranceColumns.Percentage)
		case "fragranceId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeFragranceColumns.FragranceID)
		case "recipeId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeFragranceColumns.RecipeID)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeFragranceColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeFragranceColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeFragranceColumns.UpdatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeLipidCreateInputsToBoiler(am []*gmodels.RecipeLipidCreateInput) []*models.RecipeLipid {
	ar := make([]*models.RecipeLipid, len(am))
	for i, m := range am {
		ar[i] = RecipeLipidCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeLipidCreateInputToBoiler(
	m *gmodels.RecipeLipidCreateInput,
) *models.RecipeLipid {
	if m == nil {
		return nil
	}
	r := &models.RecipeLipid{
		Percentage: m.Percentage,
		LipidID:    int(boilergql.IDToBoiler(m.LipidID)),
		RecipeID:   int(boilergql.IDToBoiler(m.RecipeID)),
		DeletedAt:  boilergql.PointerIntToNullDotTime(m.DeletedAt),
		UpdatedAt:  boilergql.IntToTimeDotTime(m.UpdatedAt),
		CreatedAt:  boilergql.IntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func RecipeLipidCreateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeLipidCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "percentage":
			modelM[models.RecipeLipidColumns.Percentage] = m.Percentage
		case "lipidId":
			modelM[models.RecipeLipidColumns.LipidID] = int(boilergql.IDToBoiler(m.LipidID))
		case "recipeId":
			modelM[models.RecipeLipidColumns.RecipeID] = int(boilergql.IDToBoiler(m.RecipeID))
		case "deletedAt":
			modelM[models.RecipeLipidColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "updatedAt":
			modelM[models.RecipeLipidColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		case "createdAt":
			modelM[models.RecipeLipidColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func RecipeLipidCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "percentage":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeLipidColumns.Percentage)
		case "lipidId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeLipidColumns.LipidID)
		case "recipeId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeLipidColumns.RecipeID)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeLipidColumns.DeletedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeLipidColumns.UpdatedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeLipidColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeLipidUpdateInputsToBoiler(am []*gmodels.RecipeLipidUpdateInput) []*models.RecipeLipid {
	ar := make([]*models.RecipeLipid, len(am))
	for i, m := range am {
		ar[i] = RecipeLipidUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeLipidUpdateInputToBoiler(
	m *gmodels.RecipeLipidUpdateInput,
) *models.RecipeLipid {
	if m == nil {
		return nil
	}
	r := &models.RecipeLipid{
		Percentage: boilergql.PointerFloat64ToFloat64(m.Percentage),
		LipidID:    int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.LipidID))),
		RecipeID:   int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeID))),
		DeletedAt:  boilergql.PointerIntToNullDotTime(m.DeletedAt),
		UpdatedAt:  boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
		CreatedAt:  boilergql.PointerIntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func RecipeLipidUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeLipidUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "percentage":
			modelM[models.RecipeLipidColumns.Percentage] = boilergql.PointerFloat64ToFloat64(m.Percentage)
		case "lipidId":
			modelM[models.RecipeLipidColumns.LipidID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.LipidID)))
		case "recipeId":
			modelM[models.RecipeLipidColumns.RecipeID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeID)))
		case "deletedAt":
			modelM[models.RecipeLipidColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "updatedAt":
			modelM[models.RecipeLipidColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		case "createdAt":
			modelM[models.RecipeLipidColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func RecipeLipidUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "percentage":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeLipidColumns.Percentage)
		case "lipidId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeLipidColumns.LipidID)
		case "recipeId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeLipidColumns.RecipeID)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeLipidColumns.DeletedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeLipidColumns.UpdatedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeLipidColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeStepCreateInputsToBoiler(am []*gmodels.RecipeStepCreateInput) []*models.RecipeStep {
	ar := make([]*models.RecipeStep, len(am))
	for i, m := range am {
		ar[i] = RecipeStepCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeStepCreateInputToBoiler(
	m *gmodels.RecipeStepCreateInput,
) *models.RecipeStep {
	if m == nil {
		return nil
	}
	r := &models.RecipeStep{
		Num:       m.Num,
		Note:      m.Note,
		RecipeID:  int(boilergql.IDToBoiler(m.RecipeID)),
		CreatedAt: boilergql.IntToTimeDotTime(m.CreatedAt),
		UpdatedAt: boilergql.IntToTimeDotTime(m.UpdatedAt),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
	}
	return r
}

func RecipeStepCreateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeStepCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "num":
			modelM[models.RecipeStepColumns.Num] = m.Num
		case "note":
			modelM[models.RecipeStepColumns.Note] = m.Note
		case "recipeId":
			modelM[models.RecipeStepColumns.RecipeID] = int(boilergql.IDToBoiler(m.RecipeID))
		case "createdAt":
			modelM[models.RecipeStepColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.RecipeStepColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		case "deletedAt":
			modelM[models.RecipeStepColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		}
	}
	return modelM
}

func RecipeStepCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "num":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeStepColumns.Num)
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeStepColumns.Note)
		case "recipeId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeStepColumns.RecipeID)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeStepColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeStepColumns.UpdatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeStepColumns.DeletedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeStepUpdateInputsToBoiler(am []*gmodels.RecipeStepUpdateInput) []*models.RecipeStep {
	ar := make([]*models.RecipeStep, len(am))
	for i, m := range am {
		ar[i] = RecipeStepUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeStepUpdateInputToBoiler(
	m *gmodels.RecipeStepUpdateInput,
) *models.RecipeStep {
	if m == nil {
		return nil
	}
	r := &models.RecipeStep{
		Num:       boilergql.PointerIntToInt(m.Num),
		Note:      boilergql.PointerStringToString(m.Note),
		RecipeID:  int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeID))),
		CreatedAt: boilergql.PointerIntToTimeDotTime(m.CreatedAt),
		UpdatedAt: boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
	}
	return r
}

func RecipeStepUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeStepUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "num":
			modelM[models.RecipeStepColumns.Num] = boilergql.PointerIntToInt(m.Num)
		case "note":
			modelM[models.RecipeStepColumns.Note] = boilergql.PointerStringToString(m.Note)
		case "recipeId":
			modelM[models.RecipeStepColumns.RecipeID] = int(boilergql.IDToBoiler(boilergql.PointerStringToString(m.RecipeID)))
		case "createdAt":
			modelM[models.RecipeStepColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.RecipeStepColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		case "deletedAt":
			modelM[models.RecipeStepColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		}
	}
	return modelM
}

func RecipeStepUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "num":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeStepColumns.Num)
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeStepColumns.Note)
		case "recipeId":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeStepColumns.RecipeID)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeStepColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeStepColumns.UpdatedAt)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeStepColumns.DeletedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func RecipeUpdateInputsToBoiler(am []*gmodels.RecipeUpdateInput) []*models.Recipe {
	ar := make([]*models.Recipe, len(am))
	for i, m := range am {
		ar[i] = RecipeUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func RecipeUpdateInputToBoiler(
	m *gmodels.RecipeUpdateInput,
) *models.Recipe {
	if m == nil {
		return nil
	}
	r := &models.Recipe{
		Name:      boilergql.PointerStringToString(m.Name),
		Note:      boilergql.PointerStringToString(m.Note),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
		CreatedAt: boilergql.PointerIntToTimeDotTime(m.CreatedAt),
		UpdatedAt: boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
	}
	return r
}

func RecipeUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.RecipeUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "name":
			modelM[models.RecipeColumns.Name] = boilergql.PointerStringToString(m.Name)
		case "note":
			modelM[models.RecipeColumns.Note] = boilergql.PointerStringToString(m.Note)
		case "deletedAt":
			modelM[models.RecipeColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "createdAt":
			modelM[models.RecipeColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		case "updatedAt":
			modelM[models.RecipeColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		}
	}
	return modelM
}

func RecipeUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "name":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeColumns.Name)
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeColumns.Note)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeColumns.DeletedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeColumns.CreatedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.RecipeColumns.UpdatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func SupplierCreateInputsToBoiler(am []*gmodels.SupplierCreateInput) []*models.Supplier {
	ar := make([]*models.Supplier, len(am))
	for i, m := range am {
		ar[i] = SupplierCreateInputToBoiler(
			m,
		)
	}
	return ar
}

func SupplierCreateInputToBoiler(
	m *gmodels.SupplierCreateInput,
) *models.Supplier {
	if m == nil {
		return nil
	}
	r := &models.Supplier{
		Name:      m.Name,
		Website:   m.Website,
		Note:      m.Note,
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
		UpdatedAt: boilergql.IntToTimeDotTime(m.UpdatedAt),
		CreatedAt: boilergql.IntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func SupplierCreateInputToModelM(
	input map[string]interface{},
	m gmodels.SupplierCreateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "name":
			modelM[models.SupplierColumns.Name] = m.Name
		case "website":
			modelM[models.SupplierColumns.Website] = m.Website
		case "note":
			modelM[models.SupplierColumns.Note] = m.Note
		case "deletedAt":
			modelM[models.SupplierColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "updatedAt":
			modelM[models.SupplierColumns.UpdatedAt] = boilergql.IntToTimeDotTime(m.UpdatedAt)
		case "createdAt":
			modelM[models.SupplierColumns.CreatedAt] = boilergql.IntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func SupplierCreateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "name":
			columnsWhichAreSet = append(columnsWhichAreSet, models.SupplierColumns.Name)
		case "website":
			columnsWhichAreSet = append(columnsWhichAreSet, models.SupplierColumns.Website)
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.SupplierColumns.Note)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.SupplierColumns.DeletedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.SupplierColumns.UpdatedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.SupplierColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}

func SupplierUpdateInputsToBoiler(am []*gmodels.SupplierUpdateInput) []*models.Supplier {
	ar := make([]*models.Supplier, len(am))
	for i, m := range am {
		ar[i] = SupplierUpdateInputToBoiler(
			m,
		)
	}
	return ar
}

func SupplierUpdateInputToBoiler(
	m *gmodels.SupplierUpdateInput,
) *models.Supplier {
	if m == nil {
		return nil
	}
	r := &models.Supplier{
		Name:      boilergql.PointerStringToString(m.Name),
		Website:   boilergql.PointerStringToString(m.Website),
		Note:      boilergql.PointerStringToString(m.Note),
		DeletedAt: boilergql.PointerIntToNullDotTime(m.DeletedAt),
		UpdatedAt: boilergql.PointerIntToTimeDotTime(m.UpdatedAt),
		CreatedAt: boilergql.PointerIntToTimeDotTime(m.CreatedAt),
	}
	return r
}

func SupplierUpdateInputToModelM(
	input map[string]interface{},
	m gmodels.SupplierUpdateInput,
) models.M {
	modelM := models.M{}
	for key := range input {
		switch key {
		case "name":
			modelM[models.SupplierColumns.Name] = boilergql.PointerStringToString(m.Name)
		case "website":
			modelM[models.SupplierColumns.Website] = boilergql.PointerStringToString(m.Website)
		case "note":
			modelM[models.SupplierColumns.Note] = boilergql.PointerStringToString(m.Note)
		case "deletedAt":
			modelM[models.SupplierColumns.DeletedAt] = boilergql.PointerIntToNullDotTime(m.DeletedAt)
		case "updatedAt":
			modelM[models.SupplierColumns.UpdatedAt] = boilergql.PointerIntToTimeDotTime(m.UpdatedAt)
		case "createdAt":
			modelM[models.SupplierColumns.CreatedAt] = boilergql.PointerIntToTimeDotTime(m.CreatedAt)
		}
	}
	return modelM
}

func SupplierUpdateInputToBoilerWhitelist(input map[string]interface{}, extraColumns ...string) boil.Columns {
	columnsWhichAreSet := []string{}
	for key := range input {
		switch key {
		case "name":
			columnsWhichAreSet = append(columnsWhichAreSet, models.SupplierColumns.Name)
		case "website":
			columnsWhichAreSet = append(columnsWhichAreSet, models.SupplierColumns.Website)
		case "note":
			columnsWhichAreSet = append(columnsWhichAreSet, models.SupplierColumns.Note)
		case "deletedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.SupplierColumns.DeletedAt)
		case "updatedAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.SupplierColumns.UpdatedAt)
		case "createdAt":
			columnsWhichAreSet = append(columnsWhichAreSet, models.SupplierColumns.CreatedAt)
		}
	}
	columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
	return boil.Whitelist(columnsWhichAreSet...)
}
