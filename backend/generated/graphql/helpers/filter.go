// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package helpers

import (
"context"
"fmt"
"io"
"strconv"
"time"
"sync"
"errors"
"bytes"
"strings"
"github.com/web-ridge/utils-go/boilergql"
gqlparser "github.com/vektah/gqlparser/v2"
"github.com/vektah/gqlparser/v2/ast"
"github.com/99designs/gqlgen/graphql"
"github.com/99designs/gqlgen/graphql/introspection"
"github.com/ericlagergren/decimal"
"github.com/volatiletech/sqlboiler/v4/boil"
"github.com/volatiletech/sqlboiler/v4/queries"
"github.com/volatiletech/sqlboiler/v4/queries/qm"
"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
"github.com/volatiletech/sqlboiler/v4/types"
null "github.com/volatiletech/null/v8"
"database/sql"
"github.com/sjhitchner/soapcalc/backend/generated/db/models"
gmodels "github.com/sjhitchner/soapcalc/backend/generated/graphql/models")





























// const regexSign = `'`
const percentSign = `%`

func startsWithValue(v string) string { return   v + percentSign   }
func endsWithValue(v string) string   { return   percentSign + v  }
func containsValue(v string) string   { return   percentSign + v + percentSign   }

const isLike = " LIKE ?"
const in = " IN ?"
const notIn = " NOT IN ?"

func appendSubQuery(queryMods []qm.QueryMod, q *queries.Query) []qm.QueryMod {
	qs, args := queries.BuildQuery(q)
	qsClean := strings.TrimSuffix(qs, ";")
	return append(queryMods, qm.Where(fmt.Sprintf("EXISTS(%v)", qsClean), args...))
}

func BooleanFilterToMods(m *gmodels.BooleanFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}
	return queryMods
}

func IDFilterToMods(m *gmodels.IDFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, boilergql.IDToBoiler(*m.EqualTo)))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, boilergql.IDToBoiler(*m.NotEqualTo)))
	}
	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + in, boilergql.IDsToBoilerInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + notIn, boilergql.IDsToBoilerInterfaces(m.NotIn)...))
	}
	return queryMods
}



func StringFilterToMods(m *gmodels.StringFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}

	var queryMods []qm.QueryMod
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}

	lowerColumn := "LOWER("+column+")"
	if m.StartWith != nil {
		queryMods = append(queryMods, qm.Where(lowerColumn+isLike, startsWithValue(strings.ToLower(*m.StartWith))))
	}
	if m.EndWith != nil {
		queryMods = append(queryMods, qm.Where(lowerColumn+isLike, endsWithValue(strings.ToLower(*m.EndWith))))
	}
	if m.Contain != nil {
		queryMods = append(queryMods, qm.Where(lowerColumn+isLike, containsValue(strings.ToLower(*m.Contain))))
	}

	if m.StartWithStrict != nil {
		queryMods = append(queryMods, qm.Where(column+isLike, startsWithValue(*m.StartWithStrict)))
	}
	if m.EndWithStrict != nil {
		queryMods = append(queryMods, qm.Where(column+isLike, endsWithValue(*m.EndWithStrict)))
	}
	if m.ContainStrict != nil {
		queryMods = append(queryMods, qm.Where(column+isLike, containsValue(*m.ContainStrict)))
	}

	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + in, boilergql.IDsToBoilerInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + notIn, boilergql.IDsToBoilerInterfaces(m.NotIn)...))
	}
	
	return queryMods
}


func FloatFilterToMods(m *gmodels.FloatFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}
	if m.LessThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LT, *m.LessThan))
	}
	if m.MoreThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GT, *m.MoreThan))
	}
	if m.LessThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LTE, *m.LessThanOrEqualTo))
	}
	if m.MoreThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GTE, *m.MoreThanOrEqualTo))
	}
	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + in, boilergql.FloatsToInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + notIn, boilergql.FloatsToInterfaces(m.NotIn)...))
	}
	return queryMods
}

func IntFilterToMods(m *gmodels.IntFilter, column string) []qm.QueryMod {
	if m == nil {
		return nil
	}
	var queryMods []qm.QueryMod
	if m.EqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.EQ, *m.EqualTo))
	}
	if m.NotEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.NEQ, *m.NotEqualTo))
	}
	if m.LessThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LT, *m.LessThan))
	}
	if m.MoreThan != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GT, *m.MoreThan))
	}
	if m.LessThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.LTE, *m.LessThanOrEqualTo))
	}
	if m.MoreThanOrEqualTo != nil {
		queryMods = append(queryMods, qmhelper.Where(column, qmhelper.GTE, *m.MoreThanOrEqualTo))
	}
	if len(m.In) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + in, boilergql.IntsToInterfaces(m.In)...))
	}
	if len(m.NotIn) > 0 {
		queryMods = append(queryMods, qm.WhereIn(column + notIn, boilergql.IntsToInterfaces(m.NotIn)...))
	}
	return queryMods
}


	
	
	func AdditiveFilterToMods(m *gmodels.AdditiveFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, AdditiveSearchToMods(m.Search)...)
				queryMods  = append(queryMods, AdditiveWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func AdditiveSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func AdditiveInventoryFilterToMods(m *gmodels.AdditiveInventoryFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, AdditiveInventorySearchToMods(m.Search)...)
				queryMods  = append(queryMods, AdditiveInventoryWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func AdditiveInventorySearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func AdditiveInventoryWhereSubqueryToMods(m *gmodels.AdditiveInventoryWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := AdditiveInventoryWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.AdditiveInventories(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func AdditiveInventoryWhereToMods(m *gmodels.AdditiveInventoryWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.AdditiveInventoryColumns.ID)...)
					}
						queryMods = append(queryMods, IntFilterToMods(m.PurchaseDate, models.AdditiveInventoryColumns.PurchaseDate)...)
						queryMods = append(queryMods, IntFilterToMods(m.ExpiryDate, models.AdditiveInventoryColumns.ExpiryDate)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Cost, models.AdditiveInventoryColumns.Cost)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Weight, models.AdditiveInventoryColumns.Weight)...)
						queryMods = append(queryMods, AdditiveWhereSubqueryToMods(m.Additive, models.AdditiveInventoryColumns.AdditiveID, models.TableNames.AdditiveInventory)...)
						queryMods = append(queryMods, SupplierWhereSubqueryToMods(m.Supplier, models.AdditiveInventoryColumns.SupplierID, models.TableNames.AdditiveInventory)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.AdditiveInventoryColumns.UpdatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.AdditiveInventoryColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.AdditiveInventoryColumns.CreatedAt)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(AdditiveInventoryWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(AdditiveInventoryWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.Additive {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.AdditiveInventory, models.AdditiveInventoryColumns.AdditiveID, parentTable)))
					}
					if parentTable == models.TableNames.Supplier {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.AdditiveInventory, models.AdditiveInventoryColumns.SupplierID, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	func AdditiveWhereSubqueryToMods(m *gmodels.AdditiveWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := AdditiveWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.Additives(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func AdditiveWhereToMods(m *gmodels.AdditiveWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.AdditiveColumns.ID)...)
					}
						queryMods = append(queryMods, StringFilterToMods(m.Name, models.AdditiveColumns.Name)...)
						queryMods = append(queryMods, StringFilterToMods(m.Note, models.AdditiveColumns.Note)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.AdditiveColumns.CreatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.AdditiveColumns.UpdatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.AdditiveColumns.DeletedAt)...)
						queryMods = append(queryMods, RecipeAdditiveWhereSubqueryToMods(m.RecipeAdditive, models.AdditiveColumns.RecipeAdditive, models.TableNames.Additive)...)
						queryMods = append(queryMods, RecipeBatchAdditiveWhereSubqueryToMods(m.RecipeBatchAdditive, models.AdditiveColumns.RecipeBatchAdditive, models.TableNames.Additive)...)
						queryMods = append(queryMods, AdditiveInventoryWhereToMods(m.AdditiveInventory, models.AdditiveColumns.)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(AdditiveWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(AdditiveWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.RecipeAdditive {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.Additive, models.AdditiveColumns.RecipeAdditive, parentTable)))
					}
					if parentTable == models.TableNames.RecipeBatchAdditive {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.Additive, models.AdditiveColumns.RecipeBatchAdditive, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	func FragranceFilterToMods(m *gmodels.FragranceFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, FragranceSearchToMods(m.Search)...)
				queryMods  = append(queryMods, FragranceWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func FragranceSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func FragranceInventoryFilterToMods(m *gmodels.FragranceInventoryFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, FragranceInventorySearchToMods(m.Search)...)
				queryMods  = append(queryMods, FragranceInventoryWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func FragranceInventorySearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func FragranceInventoryWhereSubqueryToMods(m *gmodels.FragranceInventoryWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := FragranceInventoryWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.FragranceInventories(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func FragranceInventoryWhereToMods(m *gmodels.FragranceInventoryWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.FragranceInventoryColumns.ID)...)
					}
						queryMods = append(queryMods, IntFilterToMods(m.PurchaseDate, models.FragranceInventoryColumns.PurchaseDate)...)
						queryMods = append(queryMods, IntFilterToMods(m.ExpiryDate, models.FragranceInventoryColumns.ExpiryDate)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Cost, models.FragranceInventoryColumns.Cost)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Weight, models.FragranceInventoryColumns.Weight)...)
						queryMods = append(queryMods, FragranceWhereSubqueryToMods(m.Fragrance, models.FragranceInventoryColumns.FragranceID, models.TableNames.FragranceInventory)...)
						queryMods = append(queryMods, SupplierWhereSubqueryToMods(m.Supplier, models.FragranceInventoryColumns.SupplierID, models.TableNames.FragranceInventory)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.FragranceInventoryColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.FragranceInventoryColumns.CreatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.FragranceInventoryColumns.UpdatedAt)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(FragranceInventoryWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(FragranceInventoryWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.Fragrance {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.FragranceInventory, models.FragranceInventoryColumns.FragranceID, parentTable)))
					}
					if parentTable == models.TableNames.Supplier {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.FragranceInventory, models.FragranceInventoryColumns.SupplierID, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	func FragranceWhereSubqueryToMods(m *gmodels.FragranceWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := FragranceWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.Fragrances(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func FragranceWhereToMods(m *gmodels.FragranceWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.FragranceColumns.ID)...)
					}
						queryMods = append(queryMods, StringFilterToMods(m.Name, models.FragranceColumns.Name)...)
						queryMods = append(queryMods, StringFilterToMods(m.Note, models.FragranceColumns.Note)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.FragranceColumns.CreatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.FragranceColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.FragranceColumns.UpdatedAt)...)
						queryMods = append(queryMods, RecipeBatchFragranceWhereSubqueryToMods(m.RecipeBatchFragrance, models.FragranceColumns.RecipeBatchFragrance, models.TableNames.Fragrance)...)
						queryMods = append(queryMods, RecipeFragranceWhereSubqueryToMods(m.RecipeFragrance, models.FragranceColumns.RecipeFragrance, models.TableNames.Fragrance)...)
						queryMods = append(queryMods, FragranceInventoryWhereToMods(m.FragranceInventory, models.FragranceColumns.)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(FragranceWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(FragranceWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.RecipeBatchFragrance {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.Fragrance, models.FragranceColumns.RecipeBatchFragrance, parentTable)))
					}
					if parentTable == models.TableNames.RecipeFragrance {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.Fragrance, models.FragranceColumns.RecipeFragrance, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	func LipidFilterToMods(m *gmodels.LipidFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, LipidSearchToMods(m.Search)...)
				queryMods  = append(queryMods, LipidWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func LipidSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func LipidInventoryFilterToMods(m *gmodels.LipidInventoryFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, LipidInventorySearchToMods(m.Search)...)
				queryMods  = append(queryMods, LipidInventoryWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func LipidInventorySearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func LipidInventoryWhereSubqueryToMods(m *gmodels.LipidInventoryWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := LipidInventoryWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.LipidInventories(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func LipidInventoryWhereToMods(m *gmodels.LipidInventoryWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.LipidInventoryColumns.ID)...)
					}
						queryMods = append(queryMods, IntFilterToMods(m.PurchaseDate, models.LipidInventoryColumns.PurchaseDate)...)
						queryMods = append(queryMods, IntFilterToMods(m.ExpiryDate, models.LipidInventoryColumns.ExpiryDate)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Cost, models.LipidInventoryColumns.Cost)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Weight, models.LipidInventoryColumns.Weight)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Sap, models.LipidInventoryColumns.Sap)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Naoh, models.LipidInventoryColumns.Naoh)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Koh, models.LipidInventoryColumns.Koh)...)
						queryMods = append(queryMods, FloatFilterToMods(m.GramsPerLiter, models.LipidInventoryColumns.GramsPerLiter)...)
						queryMods = append(queryMods, LipidWhereSubqueryToMods(m.Lipid, models.LipidInventoryColumns.LipidID, models.TableNames.LipidInventory)...)
						queryMods = append(queryMods, SupplierWhereSubqueryToMods(m.Supplier, models.LipidInventoryColumns.SupplierID, models.TableNames.LipidInventory)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.LipidInventoryColumns.CreatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.LipidInventoryColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.LipidInventoryColumns.UpdatedAt)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(LipidInventoryWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(LipidInventoryWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.Lipid {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.LipidInventory, models.LipidInventoryColumns.LipidID, parentTable)))
					}
					if parentTable == models.TableNames.Supplier {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.LipidInventory, models.LipidInventoryColumns.SupplierID, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	func LipidWhereSubqueryToMods(m *gmodels.LipidWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := LipidWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.Lipids(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func LipidWhereToMods(m *gmodels.LipidWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.LipidColumns.ID)...)
					}
						queryMods = append(queryMods, StringFilterToMods(m.Name, models.LipidColumns.Name)...)
						queryMods = append(queryMods, IntFilterToMods(m.Lauric, models.LipidColumns.Lauric)...)
						queryMods = append(queryMods, IntFilterToMods(m.Myristic, models.LipidColumns.Myristic)...)
						queryMods = append(queryMods, IntFilterToMods(m.Palmitic, models.LipidColumns.Palmitic)...)
						queryMods = append(queryMods, IntFilterToMods(m.Stearic, models.LipidColumns.Stearic)...)
						queryMods = append(queryMods, IntFilterToMods(m.Ricinoleic, models.LipidColumns.Ricinoleic)...)
						queryMods = append(queryMods, IntFilterToMods(m.Oleic, models.LipidColumns.Oleic)...)
						queryMods = append(queryMods, IntFilterToMods(m.Linoleic, models.LipidColumns.Linoleic)...)
						queryMods = append(queryMods, IntFilterToMods(m.Linolenic, models.LipidColumns.Linolenic)...)
						queryMods = append(queryMods, IntFilterToMods(m.Hardness, models.LipidColumns.Hardness)...)
						queryMods = append(queryMods, IntFilterToMods(m.Cleansing, models.LipidColumns.Cleansing)...)
						queryMods = append(queryMods, IntFilterToMods(m.Conditioning, models.LipidColumns.Conditioning)...)
						queryMods = append(queryMods, IntFilterToMods(m.Bubbly, models.LipidColumns.Bubbly)...)
						queryMods = append(queryMods, IntFilterToMods(m.Creamy, models.LipidColumns.Creamy)...)
						queryMods = append(queryMods, IntFilterToMods(m.Iodine, models.LipidColumns.Iodine)...)
						queryMods = append(queryMods, IntFilterToMods(m.Ins, models.LipidColumns.Ins)...)
						queryMods = append(queryMods, StringFilterToMods(m.InciName, models.LipidColumns.InciName)...)
						queryMods = append(queryMods, StringFilterToMods(m.Family, models.LipidColumns.Family)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Naoh, models.LipidColumns.Naoh)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.LipidColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.LipidColumns.CreatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.LipidColumns.UpdatedAt)...)
						queryMods = append(queryMods, RecipeBatchLipidWhereSubqueryToMods(m.RecipeBatchLipid, models.LipidColumns.RecipeBatchLipid, models.TableNames.Lipid)...)
						queryMods = append(queryMods, RecipeLipidWhereSubqueryToMods(m.RecipeLipid, models.LipidColumns.RecipeLipid, models.TableNames.Lipid)...)
						queryMods = append(queryMods, LipidInventoryWhereToMods(m.LipidInventory, models.LipidColumns.)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(LipidWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(LipidWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.RecipeBatchLipid {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.Lipid, models.LipidColumns.RecipeBatchLipid, parentTable)))
					}
					if parentTable == models.TableNames.RecipeLipid {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.Lipid, models.LipidColumns.RecipeLipid, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	func LyeFilterToMods(m *gmodels.LyeFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, LyeSearchToMods(m.Search)...)
				queryMods  = append(queryMods, LyeWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func LyeSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func LyeInventoryFilterToMods(m *gmodels.LyeInventoryFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, LyeInventorySearchToMods(m.Search)...)
				queryMods  = append(queryMods, LyeInventoryWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func LyeInventorySearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func LyeInventoryWhereSubqueryToMods(m *gmodels.LyeInventoryWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := LyeInventoryWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.LyeInventories(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func LyeInventoryWhereToMods(m *gmodels.LyeInventoryWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.LyeInventoryColumns.ID)...)
					}
						queryMods = append(queryMods, IntFilterToMods(m.PurchaseDate, models.LyeInventoryColumns.PurchaseDate)...)
						queryMods = append(queryMods, IntFilterToMods(m.ExpiryDate, models.LyeInventoryColumns.ExpiryDate)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Cost, models.LyeInventoryColumns.Cost)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Weight, models.LyeInventoryColumns.Weight)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Concentration, models.LyeInventoryColumns.Concentration)...)
						queryMods = append(queryMods, LyeWhereSubqueryToMods(m.Lye, models.LyeInventoryColumns.LyeID, models.TableNames.LyeInventory)...)
						queryMods = append(queryMods, SupplierWhereSubqueryToMods(m.Supplier, models.LyeInventoryColumns.SupplierID, models.TableNames.LyeInventory)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.LyeInventoryColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.LyeInventoryColumns.CreatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.LyeInventoryColumns.UpdatedAt)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(LyeInventoryWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(LyeInventoryWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.Lye {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.LyeInventory, models.LyeInventoryColumns.LyeID, parentTable)))
					}
					if parentTable == models.TableNames.Supplier {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.LyeInventory, models.LyeInventoryColumns.SupplierID, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	func LyeWhereSubqueryToMods(m *gmodels.LyeWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := LyeWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.Lyes(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func LyeWhereToMods(m *gmodels.LyeWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.LyeColumns.ID)...)
					}
						queryMods = append(queryMods, StringFilterToMods(m.Kind, models.LyeColumns.Kind)...)
						queryMods = append(queryMods, StringFilterToMods(m.Name, models.LyeColumns.Name)...)
						queryMods = append(queryMods, StringFilterToMods(m.Note, models.LyeColumns.Note)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.LyeColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.LyeColumns.UpdatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.LyeColumns.CreatedAt)...)
						queryMods = append(queryMods, RecipeBatchLyeWhereSubqueryToMods(m.RecipeBatchLye, models.LyeColumns.RecipeBatchLye, models.TableNames.Lye)...)
						queryMods = append(queryMods, LyeInventoryWhereToMods(m.LyeInventory, models.LyeColumns.)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(LyeWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(LyeWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.RecipeBatchLye {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.Lye, models.LyeColumns.RecipeBatchLye, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	
	func RecipeAdditiveFilterToMods(m *gmodels.RecipeAdditiveFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, RecipeAdditiveSearchToMods(m.Search)...)
				queryMods  = append(queryMods, RecipeAdditiveWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func RecipeAdditiveSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func RecipeAdditiveWhereSubqueryToMods(m *gmodels.RecipeAdditiveWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := RecipeAdditiveWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.RecipeAdditives(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func RecipeAdditiveWhereToMods(m *gmodels.RecipeAdditiveWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.RecipeAdditiveColumns.ID)...)
					}
						queryMods = append(queryMods, FloatFilterToMods(m.Percentage, models.RecipeAdditiveColumns.Percentage)...)
						queryMods = append(queryMods, AdditiveWhereSubqueryToMods(m.Additive, models.RecipeAdditiveColumns.AdditiveID, models.TableNames.RecipeAdditive)...)
						queryMods = append(queryMods, RecipeWhereSubqueryToMods(m.Recipe, models.RecipeAdditiveColumns.RecipeID, models.TableNames.RecipeAdditive)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.RecipeAdditiveColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.RecipeAdditiveColumns.CreatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.RecipeAdditiveColumns.UpdatedAt)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(RecipeAdditiveWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(RecipeAdditiveWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.Additive {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeAdditive, models.RecipeAdditiveColumns.AdditiveID, parentTable)))
					}
					if parentTable == models.TableNames.Recipe {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeAdditive, models.RecipeAdditiveColumns.RecipeID, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	
	func RecipeBatchAdditiveFilterToMods(m *gmodels.RecipeBatchAdditiveFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, RecipeBatchAdditiveSearchToMods(m.Search)...)
				queryMods  = append(queryMods, RecipeBatchAdditiveWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func RecipeBatchAdditiveSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func RecipeBatchAdditiveWhereSubqueryToMods(m *gmodels.RecipeBatchAdditiveWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := RecipeBatchAdditiveWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.RecipeBatchAdditives(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func RecipeBatchAdditiveWhereToMods(m *gmodels.RecipeBatchAdditiveWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.RecipeBatchAdditiveColumns.ID)...)
					}
						queryMods = append(queryMods, FloatFilterToMods(m.Weight, models.RecipeBatchAdditiveColumns.Weight)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Cost, models.RecipeBatchAdditiveColumns.Cost)...)
						queryMods = append(queryMods, AdditiveWhereSubqueryToMods(m.Additive, models.RecipeBatchAdditiveColumns.AdditiveID, models.TableNames.RecipeBatchAdditive)...)
						queryMods = append(queryMods, RecipeBatchWhereSubqueryToMods(m.Batch, models.RecipeBatchAdditiveColumns.BatchID, models.TableNames.RecipeBatchAdditive)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.RecipeBatchAdditiveColumns.CreatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.RecipeBatchAdditiveColumns.UpdatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.RecipeBatchAdditiveColumns.DeletedAt)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(RecipeBatchAdditiveWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(RecipeBatchAdditiveWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.Additive {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeBatchAdditive, models.RecipeBatchAdditiveColumns.AdditiveID, parentTable)))
					}
					if parentTable == models.TableNames.RecipeBatch {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeBatchAdditive, models.RecipeBatchAdditiveColumns.BatchID, parentTable)))
					}

			}



			return queryMods
		}
	
	
	func RecipeBatchFilterToMods(m *gmodels.RecipeBatchFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, RecipeBatchSearchToMods(m.Search)...)
				queryMods  = append(queryMods, RecipeBatchWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func RecipeBatchSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func RecipeBatchFragranceFilterToMods(m *gmodels.RecipeBatchFragranceFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, RecipeBatchFragranceSearchToMods(m.Search)...)
				queryMods  = append(queryMods, RecipeBatchFragranceWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func RecipeBatchFragranceSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func RecipeBatchFragranceWhereSubqueryToMods(m *gmodels.RecipeBatchFragranceWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := RecipeBatchFragranceWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.RecipeBatchFragrances(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func RecipeBatchFragranceWhereToMods(m *gmodels.RecipeBatchFragranceWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.RecipeBatchFragranceColumns.ID)...)
					}
						queryMods = append(queryMods, FloatFilterToMods(m.Weight, models.RecipeBatchFragranceColumns.Weight)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Cost, models.RecipeBatchFragranceColumns.Cost)...)
						queryMods = append(queryMods, FragranceWhereSubqueryToMods(m.Fragrance, models.RecipeBatchFragranceColumns.FragranceID, models.TableNames.RecipeBatchFragrance)...)
						queryMods = append(queryMods, RecipeBatchWhereSubqueryToMods(m.Batch, models.RecipeBatchFragranceColumns.BatchID, models.TableNames.RecipeBatchFragrance)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.RecipeBatchFragranceColumns.UpdatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.RecipeBatchFragranceColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.RecipeBatchFragranceColumns.CreatedAt)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(RecipeBatchFragranceWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(RecipeBatchFragranceWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.Fragrance {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeBatchFragrance, models.RecipeBatchFragranceColumns.FragranceID, parentTable)))
					}
					if parentTable == models.TableNames.RecipeBatch {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeBatchFragrance, models.RecipeBatchFragranceColumns.BatchID, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	func RecipeBatchLipidFilterToMods(m *gmodels.RecipeBatchLipidFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, RecipeBatchLipidSearchToMods(m.Search)...)
				queryMods  = append(queryMods, RecipeBatchLipidWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func RecipeBatchLipidSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func RecipeBatchLipidWhereSubqueryToMods(m *gmodels.RecipeBatchLipidWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := RecipeBatchLipidWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.RecipeBatchLipids(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func RecipeBatchLipidWhereToMods(m *gmodels.RecipeBatchLipidWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.RecipeBatchLipidColumns.ID)...)
					}
						queryMods = append(queryMods, FloatFilterToMods(m.Weight, models.RecipeBatchLipidColumns.Weight)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Cost, models.RecipeBatchLipidColumns.Cost)...)
						queryMods = append(queryMods, LipidWhereSubqueryToMods(m.Lipid, models.RecipeBatchLipidColumns.LipidID, models.TableNames.RecipeBatchLipid)...)
						queryMods = append(queryMods, RecipeBatchWhereSubqueryToMods(m.Batch, models.RecipeBatchLipidColumns.BatchID, models.TableNames.RecipeBatchLipid)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.RecipeBatchLipidColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.RecipeBatchLipidColumns.UpdatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.RecipeBatchLipidColumns.CreatedAt)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(RecipeBatchLipidWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(RecipeBatchLipidWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.Lipid {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeBatchLipid, models.RecipeBatchLipidColumns.LipidID, parentTable)))
					}
					if parentTable == models.TableNames.RecipeBatch {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeBatchLipid, models.RecipeBatchLipidColumns.BatchID, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	func RecipeBatchLyeFilterToMods(m *gmodels.RecipeBatchLyeFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, RecipeBatchLyeSearchToMods(m.Search)...)
				queryMods  = append(queryMods, RecipeBatchLyeWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func RecipeBatchLyeSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func RecipeBatchLyeWhereSubqueryToMods(m *gmodels.RecipeBatchLyeWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := RecipeBatchLyeWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.RecipeBatchLyes(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func RecipeBatchLyeWhereToMods(m *gmodels.RecipeBatchLyeWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.RecipeBatchLyeColumns.ID)...)
					}
						queryMods = append(queryMods, FloatFilterToMods(m.Weight, models.RecipeBatchLyeColumns.Weight)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Discount, models.RecipeBatchLyeColumns.Discount)...)
						queryMods = append(queryMods, FloatFilterToMods(m.Cost, models.RecipeBatchLyeColumns.Cost)...)
						queryMods = append(queryMods, LyeWhereSubqueryToMods(m.Lye, models.RecipeBatchLyeColumns.LyeID, models.TableNames.RecipeBatchLye)...)
						queryMods = append(queryMods, RecipeBatchWhereSubqueryToMods(m.Batch, models.RecipeBatchLyeColumns.BatchID, models.TableNames.RecipeBatchLye)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.RecipeBatchLyeColumns.UpdatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.RecipeBatchLyeColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.RecipeBatchLyeColumns.CreatedAt)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(RecipeBatchLyeWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(RecipeBatchLyeWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.Lye {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeBatchLye, models.RecipeBatchLyeColumns.LyeID, parentTable)))
					}
					if parentTable == models.TableNames.RecipeBatch {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeBatchLye, models.RecipeBatchLyeColumns.BatchID, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	func RecipeBatchNoteFilterToMods(m *gmodels.RecipeBatchNoteFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, RecipeBatchNoteSearchToMods(m.Search)...)
				queryMods  = append(queryMods, RecipeBatchNoteWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func RecipeBatchNoteSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func RecipeBatchNoteWhereSubqueryToMods(m *gmodels.RecipeBatchNoteWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := RecipeBatchNoteWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.RecipeBatchNotes(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func RecipeBatchNoteWhereToMods(m *gmodels.RecipeBatchNoteWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.RecipeBatchNoteColumns.ID)...)
					}
						queryMods = append(queryMods, StringFilterToMods(m.Note, models.RecipeBatchNoteColumns.Note)...)
						queryMods = append(queryMods, StringFilterToMods(m.Link, models.RecipeBatchNoteColumns.Link)...)
						queryMods = append(queryMods, RecipeBatchWhereSubqueryToMods(m.Batch, models.RecipeBatchNoteColumns.BatchID, models.TableNames.RecipeBatchNote)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.RecipeBatchNoteColumns.CreatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.RecipeBatchNoteColumns.UpdatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.RecipeBatchNoteColumns.DeletedAt)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(RecipeBatchNoteWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(RecipeBatchNoteWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.RecipeBatch {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeBatchNote, models.RecipeBatchNoteColumns.BatchID, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	func RecipeBatchWhereSubqueryToMods(m *gmodels.RecipeBatchWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := RecipeBatchWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.RecipeBatches(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func RecipeBatchWhereToMods(m *gmodels.RecipeBatchWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.RecipeBatchColumns.ID)...)
					}
						queryMods = append(queryMods, StringFilterToMods(m.Tag, models.RecipeBatchColumns.Tag)...)
						queryMods = append(queryMods, IntFilterToMods(m.ProductionDate, models.RecipeBatchColumns.ProductionDate)...)
						queryMods = append(queryMods, IntFilterToMods(m.SellableDate, models.RecipeBatchColumns.SellableDate)...)
						queryMods = append(queryMods, StringFilterToMods(m.Note, models.RecipeBatchColumns.Note)...)
						queryMods = append(queryMods, FloatFilterToMods(m.LipidWeight, models.RecipeBatchColumns.LipidWeight)...)
						queryMods = append(queryMods, FloatFilterToMods(m.ProductionWeight, models.RecipeBatchColumns.ProductionWeight)...)
						queryMods = append(queryMods, FloatFilterToMods(m.CuredWeight, models.RecipeBatchColumns.CuredWeight)...)
						queryMods = append(queryMods, RecipeWhereSubqueryToMods(m.Recipe, models.RecipeBatchColumns.RecipeID, models.TableNames.RecipeBatch)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.RecipeBatchColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.RecipeBatchColumns.UpdatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.RecipeBatchColumns.CreatedAt)...)
						queryMods = append(queryMods, RecipeBatchAdditiveWhereSubqueryToMods(m.BatchRecipeBatchAdditives, "", models.TableNames.RecipeBatch)...)
						queryMods = append(queryMods, RecipeBatchFragranceWhereSubqueryToMods(m.BatchRecipeBatchFragrances, "", models.TableNames.RecipeBatch)...)
						queryMods = append(queryMods, RecipeBatchLipidWhereSubqueryToMods(m.BatchRecipeBatchLipids, "", models.TableNames.RecipeBatch)...)
						queryMods = append(queryMods, RecipeBatchLyeWhereSubqueryToMods(m.BatchRecipeBatchLyes, "", models.TableNames.RecipeBatch)...)
						queryMods = append(queryMods, RecipeBatchNoteWhereSubqueryToMods(m.BatchRecipeBatchNotes, "", models.TableNames.RecipeBatch)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(RecipeBatchWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(RecipeBatchWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.Recipe {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeBatch, models.RecipeBatchColumns.RecipeID, parentTable)))
					}
					if parentTable == models.TableNames.RecipeBatchAdditive {
					}
					if parentTable == models.TableNames.RecipeBatchFragrance {
					}
					if parentTable == models.TableNames.RecipeBatchLipid {
					}
					if parentTable == models.TableNames.RecipeBatchLye {
					}
					if parentTable == models.TableNames.RecipeBatchNote {
					}

			}



			return queryMods
		}
	
	
	func RecipeFilterToMods(m *gmodels.RecipeFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, RecipeSearchToMods(m.Search)...)
				queryMods  = append(queryMods, RecipeWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func RecipeSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func RecipeFragranceFilterToMods(m *gmodels.RecipeFragranceFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, RecipeFragranceSearchToMods(m.Search)...)
				queryMods  = append(queryMods, RecipeFragranceWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func RecipeFragranceSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func RecipeFragranceWhereSubqueryToMods(m *gmodels.RecipeFragranceWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := RecipeFragranceWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.RecipeFragrances(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func RecipeFragranceWhereToMods(m *gmodels.RecipeFragranceWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.RecipeFragranceColumns.ID)...)
					}
						queryMods = append(queryMods, FloatFilterToMods(m.Percentage, models.RecipeFragranceColumns.Percentage)...)
						queryMods = append(queryMods, FragranceWhereSubqueryToMods(m.Fragrance, models.RecipeFragranceColumns.FragranceID, models.TableNames.RecipeFragrance)...)
						queryMods = append(queryMods, RecipeWhereSubqueryToMods(m.Recipe, models.RecipeFragranceColumns.RecipeID, models.TableNames.RecipeFragrance)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.RecipeFragranceColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.RecipeFragranceColumns.CreatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.RecipeFragranceColumns.UpdatedAt)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(RecipeFragranceWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(RecipeFragranceWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.Fragrance {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeFragrance, models.RecipeFragranceColumns.FragranceID, parentTable)))
					}
					if parentTable == models.TableNames.Recipe {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeFragrance, models.RecipeFragranceColumns.RecipeID, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	func RecipeLipidFilterToMods(m *gmodels.RecipeLipidFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, RecipeLipidSearchToMods(m.Search)...)
				queryMods  = append(queryMods, RecipeLipidWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func RecipeLipidSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func RecipeLipidWhereSubqueryToMods(m *gmodels.RecipeLipidWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := RecipeLipidWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.RecipeLipids(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func RecipeLipidWhereToMods(m *gmodels.RecipeLipidWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.RecipeLipidColumns.ID)...)
					}
						queryMods = append(queryMods, FloatFilterToMods(m.Percentage, models.RecipeLipidColumns.Percentage)...)
						queryMods = append(queryMods, LipidWhereSubqueryToMods(m.Lipid, models.RecipeLipidColumns.LipidID, models.TableNames.RecipeLipid)...)
						queryMods = append(queryMods, RecipeWhereSubqueryToMods(m.Recipe, models.RecipeLipidColumns.RecipeID, models.TableNames.RecipeLipid)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.RecipeLipidColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.RecipeLipidColumns.UpdatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.RecipeLipidColumns.CreatedAt)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(RecipeLipidWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(RecipeLipidWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.Lipid {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeLipid, models.RecipeLipidColumns.LipidID, parentTable)))
					}
					if parentTable == models.TableNames.Recipe {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeLipid, models.RecipeLipidColumns.RecipeID, parentTable)))
					}

			}



			return queryMods
		}
	
	
	
	
	func RecipeStepFilterToMods(m *gmodels.RecipeStepFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, RecipeStepSearchToMods(m.Search)...)
				queryMods  = append(queryMods, RecipeStepWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func RecipeStepSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func RecipeStepWhereSubqueryToMods(m *gmodels.RecipeStepWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := RecipeStepWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.RecipeSteps(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func RecipeStepWhereToMods(m *gmodels.RecipeStepWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.RecipeStepColumns.ID)...)
					}
						queryMods = append(queryMods, IntFilterToMods(m.Num, models.RecipeStepColumns.Num)...)
						queryMods = append(queryMods, StringFilterToMods(m.Note, models.RecipeStepColumns.Note)...)
						queryMods = append(queryMods, RecipeWhereSubqueryToMods(m.Recipe, models.RecipeStepColumns.RecipeID, models.TableNames.RecipeStep)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.RecipeStepColumns.CreatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.RecipeStepColumns.UpdatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.RecipeStepColumns.DeletedAt)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(RecipeStepWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(RecipeStepWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.Recipe {
						queryMods = append(queryMods, qm.Where(fmt.Sprintf("%v.%v = %v.id", models.TableNames.RecipeStep, models.RecipeStepColumns.RecipeID, parentTable)))
					}

			}



			return queryMods
		}
	
	
	func RecipeWhereSubqueryToMods(m *gmodels.RecipeWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := RecipeWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.Recipes(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func RecipeWhereToMods(m *gmodels.RecipeWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.RecipeColumns.ID)...)
					}
						queryMods = append(queryMods, StringFilterToMods(m.Name, models.RecipeColumns.Name)...)
						queryMods = append(queryMods, StringFilterToMods(m.Note, models.RecipeColumns.Note)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.RecipeColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.RecipeColumns.CreatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.RecipeColumns.UpdatedAt)...)
						queryMods = append(queryMods, RecipeAdditiveWhereSubqueryToMods(m.RecipeAdditives, "", models.TableNames.Recipe)...)
						queryMods = append(queryMods, RecipeBatchWhereSubqueryToMods(m.RecipeBatches, "", models.TableNames.Recipe)...)
						queryMods = append(queryMods, RecipeFragranceWhereSubqueryToMods(m.RecipeFragrances, "", models.TableNames.Recipe)...)
						queryMods = append(queryMods, RecipeLipidWhereSubqueryToMods(m.RecipeLipids, "", models.TableNames.Recipe)...)
						queryMods = append(queryMods, RecipeStepWhereSubqueryToMods(m.RecipeSteps, "", models.TableNames.Recipe)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(RecipeWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(RecipeWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				
					if parentTable == models.TableNames.RecipeAdditive {
					}
					if parentTable == models.TableNames.RecipeBatch {
					}
					if parentTable == models.TableNames.RecipeFragrance {
					}
					if parentTable == models.TableNames.RecipeLipid {
					}
					if parentTable == models.TableNames.RecipeStep {
					}

			}



			return queryMods
		}
	
	
	
	func SupplierFilterToMods(m *gmodels.SupplierFilter) []qm.QueryMod {
			if m == nil {
				return nil
			}
			if m.Search != nil || m.Where != nil {
				var queryMods []qm.QueryMod
				queryMods  = append(queryMods, SupplierSearchToMods(m.Search)...)
				queryMods  = append(queryMods, SupplierWhereToMods(m.Where, true, "")...)
				if len(queryMods) > 0 {
					return []qm.QueryMod{
						qm.Expr(queryMods...),
					}
				}
			}
			return nil
		}
		func SupplierSearchToMods(search *string) []qm.QueryMod {
			// TODO: implement your own custom search here
			return nil
		}
	
	
	
	func SupplierWhereSubqueryToMods(m *gmodels.SupplierWhere, foreignColumn string, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod

			// if foreign key exist so we can filter on ID in the root table instead of subquery
			hasForeignKeyInRoot := foreignColumn != ""
			if hasForeignKeyInRoot {
				queryMods = append(queryMods, IDFilterToMods(m.ID, foreignColumn)...)
			}
		
			subQueryMods := SupplierWhereToMods(m, !hasForeignKeyInRoot, parentTable)
			if len(subQueryMods) > 0 {
				subQuery := models.Suppliers(append(subQueryMods, qm.Select("1"))...)
				queryMods = appendSubQuery(queryMods, subQuery.Query)
			}
			return queryMods
		} 
		
		func SupplierWhereToMods(m *gmodels.SupplierWhere, withPrimaryID bool, parentTable string) []qm.QueryMod {
			if m == nil {
				return nil
			}
			var queryMods []qm.QueryMod
	
			
			
					if withPrimaryID {
						queryMods = append(queryMods, IDFilterToMods(m.ID, models.SupplierColumns.ID)...)
					}
						queryMods = append(queryMods, StringFilterToMods(m.Name, models.SupplierColumns.Name)...)
						queryMods = append(queryMods, StringFilterToMods(m.Website, models.SupplierColumns.Website)...)
						queryMods = append(queryMods, StringFilterToMods(m.Note, models.SupplierColumns.Note)...)
						queryMods = append(queryMods, IntFilterToMods(m.DeletedAt, models.SupplierColumns.DeletedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.UpdatedAt, models.SupplierColumns.UpdatedAt)...)
						queryMods = append(queryMods, IntFilterToMods(m.CreatedAt, models.SupplierColumns.CreatedAt)...)
						queryMods = append(queryMods, AdditiveInventoryWhereToMods(m.AdditiveInventory, models.SupplierColumns.)...)
						queryMods = append(queryMods, FragranceInventoryWhereToMods(m.FragranceInventory, models.SupplierColumns.)...)
						queryMods = append(queryMods, LipidInventoryWhereToMods(m.LipidInventory, models.SupplierColumns.)...)
						queryMods = append(queryMods, LyeInventoryWhereToMods(m.LyeInventory, models.SupplierColumns.)...)
					if m.Or != nil {
						queryMods = append(queryMods, qm.Or2(qm.Expr(SupplierWhereToMods(m.Or, true, "")...)))
					}
					if m.And != nil {
						queryMods = append(queryMods, qm.Expr(SupplierWhereToMods(m.And, true, "")...))
					}

			if len(queryMods) > 0 && parentTable != "" {
				

			}



			return queryMods
		}
	
