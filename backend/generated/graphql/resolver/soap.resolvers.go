package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.

import (
	"context"
	"fmt"

	graphql1 "github.com/sjhitchner/soapcalc/backend/generated/graphql/models"
	"github.com/sjhitchner/soapcalc/backend/generated/graphql/server"
)

func (r *mutationResolver) CreateAdditive(ctx context.Context, input graphql1.AdditiveCreateInput) (*graphql1.AdditivePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateAdditive(ctx context.Context, id string, input graphql1.AdditiveUpdateInput) (*graphql1.AdditivePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteAdditive(ctx context.Context, id string) (*graphql1.AdditiveDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateAdditiveInventory(ctx context.Context, input graphql1.AdditiveInventoryCreateInput) (*graphql1.AdditiveInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateAdditiveInventory(ctx context.Context, id string, input graphql1.AdditiveInventoryUpdateInput) (*graphql1.AdditiveInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteAdditiveInventory(ctx context.Context, id string) (*graphql1.AdditiveInventoryDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateFragrance(ctx context.Context, input graphql1.FragranceCreateInput) (*graphql1.FragrancePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateFragrance(ctx context.Context, id string, input graphql1.FragranceUpdateInput) (*graphql1.FragrancePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteFragrance(ctx context.Context, id string) (*graphql1.FragranceDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateFragranceInventory(ctx context.Context, input graphql1.FragranceInventoryCreateInput) (*graphql1.FragranceInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateFragranceInventory(ctx context.Context, id string, input graphql1.FragranceInventoryUpdateInput) (*graphql1.FragranceInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteFragranceInventory(ctx context.Context, id string) (*graphql1.FragranceInventoryDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateLipid(ctx context.Context, input graphql1.LipidCreateInput) (*graphql1.LipidPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateLipid(ctx context.Context, id string, input graphql1.LipidUpdateInput) (*graphql1.LipidPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteLipid(ctx context.Context, id string) (*graphql1.LipidDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateLipidInventory(ctx context.Context, input graphql1.LipidInventoryCreateInput) (*graphql1.LipidInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateLipidInventory(ctx context.Context, id string, input graphql1.LipidInventoryUpdateInput) (*graphql1.LipidInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteLipidInventory(ctx context.Context, id string) (*graphql1.LipidInventoryDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateLye(ctx context.Context, input graphql1.LyeCreateInput) (*graphql1.LyePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateLye(ctx context.Context, id string, input graphql1.LyeUpdateInput) (*graphql1.LyePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteLye(ctx context.Context, id string) (*graphql1.LyeDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateLyeInventory(ctx context.Context, input graphql1.LyeInventoryCreateInput) (*graphql1.LyeInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateLyeInventory(ctx context.Context, id string, input graphql1.LyeInventoryUpdateInput) (*graphql1.LyeInventoryPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteLyeInventory(ctx context.Context, id string) (*graphql1.LyeInventoryDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipe(ctx context.Context, input graphql1.RecipeCreateInput) (*graphql1.RecipePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipe(ctx context.Context, id string, input graphql1.RecipeUpdateInput) (*graphql1.RecipePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipe(ctx context.Context, id string) (*graphql1.RecipeDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeAdditive(ctx context.Context, input graphql1.RecipeAdditiveCreateInput) (*graphql1.RecipeAdditivePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeAdditive(ctx context.Context, id string, input graphql1.RecipeAdditiveUpdateInput) (*graphql1.RecipeAdditivePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeAdditive(ctx context.Context, id string) (*graphql1.RecipeAdditiveDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeBatch(ctx context.Context, input graphql1.RecipeBatchCreateInput) (*graphql1.RecipeBatchPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeBatch(ctx context.Context, id string, input graphql1.RecipeBatchUpdateInput) (*graphql1.RecipeBatchPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeBatch(ctx context.Context, id string) (*graphql1.RecipeBatchDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeBatchAdditive(ctx context.Context, input graphql1.RecipeBatchAdditiveCreateInput) (*graphql1.RecipeBatchAdditivePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeBatchAdditive(ctx context.Context, id string, input graphql1.RecipeBatchAdditiveUpdateInput) (*graphql1.RecipeBatchAdditivePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeBatchAdditive(ctx context.Context, id string) (*graphql1.RecipeBatchAdditiveDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeBatchFragrance(ctx context.Context, input graphql1.RecipeBatchFragranceCreateInput) (*graphql1.RecipeBatchFragrancePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeBatchFragrance(ctx context.Context, id string, input graphql1.RecipeBatchFragranceUpdateInput) (*graphql1.RecipeBatchFragrancePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeBatchFragrance(ctx context.Context, id string) (*graphql1.RecipeBatchFragranceDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeBatchLipid(ctx context.Context, input graphql1.RecipeBatchLipidCreateInput) (*graphql1.RecipeBatchLipidPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeBatchLipid(ctx context.Context, id string, input graphql1.RecipeBatchLipidUpdateInput) (*graphql1.RecipeBatchLipidPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeBatchLipid(ctx context.Context, id string) (*graphql1.RecipeBatchLipidDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeBatchLye(ctx context.Context, input graphql1.RecipeBatchLyeCreateInput) (*graphql1.RecipeBatchLyePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeBatchLye(ctx context.Context, id string, input graphql1.RecipeBatchLyeUpdateInput) (*graphql1.RecipeBatchLyePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeBatchLye(ctx context.Context, id string) (*graphql1.RecipeBatchLyeDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeFragrance(ctx context.Context, input graphql1.RecipeFragranceCreateInput) (*graphql1.RecipeFragrancePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeFragrance(ctx context.Context, id string, input graphql1.RecipeFragranceUpdateInput) (*graphql1.RecipeFragrancePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeFragrance(ctx context.Context, id string) (*graphql1.RecipeFragranceDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateRecipeLipid(ctx context.Context, input graphql1.RecipeLipidCreateInput) (*graphql1.RecipeLipidPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateRecipeLipid(ctx context.Context, id string, input graphql1.RecipeLipidUpdateInput) (*graphql1.RecipeLipidPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteRecipeLipid(ctx context.Context, id string) (*graphql1.RecipeLipidDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) CreateSupplier(ctx context.Context, input graphql1.SupplierCreateInput) (*graphql1.SupplierPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) UpdateSupplier(ctx context.Context, id string, input graphql1.SupplierUpdateInput) (*graphql1.SupplierPayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *mutationResolver) DeleteSupplier(ctx context.Context, id string) (*graphql1.SupplierDeletePayload, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Additive(ctx context.Context, id string) (*graphql1.Additive, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Additives(ctx context.Context, filter *graphql1.AdditiveFilter) ([]*graphql1.Additive, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) AdditiveInventory(ctx context.Context, id string) (*graphql1.AdditiveInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) AdditiveInventories(ctx context.Context, filter *graphql1.AdditiveInventoryFilter) ([]*graphql1.AdditiveInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Fragrance(ctx context.Context, id string) (*graphql1.Fragrance, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Fragrances(ctx context.Context, filter *graphql1.FragranceFilter) ([]*graphql1.Fragrance, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) FragranceInventory(ctx context.Context, id string) (*graphql1.FragranceInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) FragranceInventories(ctx context.Context, filter *graphql1.FragranceInventoryFilter) ([]*graphql1.FragranceInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Lipid(ctx context.Context, id string) (*graphql1.Lipid, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Lipids(ctx context.Context, filter *graphql1.LipidFilter) ([]*graphql1.Lipid, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) LipidInventory(ctx context.Context, id string) (*graphql1.LipidInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) LipidInventories(ctx context.Context, filter *graphql1.LipidInventoryFilter) ([]*graphql1.LipidInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Lye(ctx context.Context, id string) (*graphql1.Lye, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Lyes(ctx context.Context, filter *graphql1.LyeFilter) ([]*graphql1.Lye, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) LyeInventory(ctx context.Context, id string) (*graphql1.LyeInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) LyeInventories(ctx context.Context, filter *graphql1.LyeInventoryFilter) ([]*graphql1.LyeInventory, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Recipe(ctx context.Context, id string) (*graphql1.Recipe, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Recipes(ctx context.Context, filter *graphql1.RecipeFilter) ([]*graphql1.Recipe, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeAdditive(ctx context.Context, id string) (*graphql1.RecipeAdditive, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeAdditives(ctx context.Context, filter *graphql1.RecipeAdditiveFilter) ([]*graphql1.RecipeAdditive, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatch(ctx context.Context, id string) (*graphql1.RecipeBatch, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatches(ctx context.Context, filter *graphql1.RecipeBatchFilter) ([]*graphql1.RecipeBatch, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchAdditive(ctx context.Context, id string) (*graphql1.RecipeBatchAdditive, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchAdditives(ctx context.Context, filter *graphql1.RecipeBatchAdditiveFilter) ([]*graphql1.RecipeBatchAdditive, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchFragrance(ctx context.Context, id string) (*graphql1.RecipeBatchFragrance, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchFragrances(ctx context.Context, filter *graphql1.RecipeBatchFragranceFilter) ([]*graphql1.RecipeBatchFragrance, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchLipid(ctx context.Context, id string) (*graphql1.RecipeBatchLipid, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchLipids(ctx context.Context, filter *graphql1.RecipeBatchLipidFilter) ([]*graphql1.RecipeBatchLipid, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchLye(ctx context.Context, id string) (*graphql1.RecipeBatchLye, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeBatchLyes(ctx context.Context, filter *graphql1.RecipeBatchLyeFilter) ([]*graphql1.RecipeBatchLye, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeFragrance(ctx context.Context, id string) (*graphql1.RecipeFragrance, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeFragrances(ctx context.Context, filter *graphql1.RecipeFragranceFilter) ([]*graphql1.RecipeFragrance, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeLipid(ctx context.Context, id string) (*graphql1.RecipeLipid, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) RecipeLipids(ctx context.Context, filter *graphql1.RecipeLipidFilter) ([]*graphql1.RecipeLipid, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Supplier(ctx context.Context, id string) (*graphql1.Supplier, error) {
	panic(fmt.Errorf("not implemented"))
}

func (r *queryResolver) Suppliers(ctx context.Context, filter *graphql1.SupplierFilter) ([]*graphql1.Supplier, error) {
	panic(fmt.Errorf("not implemented"))
}

// Mutation returns server.MutationResolver implementation.
func (r *Resolver) Mutation() server.MutationResolver { return &mutationResolver{r} }

// Query returns server.QueryResolver implementation.
func (r *Resolver) Query() server.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
